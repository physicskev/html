<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR Digital Manhattan - Bitcoin Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            font-family: 'Courier New', monospace;
            color: #FFD700;
            overflow: hidden;
        }

        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #three-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #controls-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(10, 10, 10, 0.8);
            border: 1px solid #FFD700;
            border-radius: 8px;
            padding: 15px;
            min-width: 250px;
            backdrop-filter: blur(5px);
            transition: opacity 0.5s ease-in-out;
            opacity: 1;
        }

        #controls-panel.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(10, 10, 10, 0.8);
            border: 1px solid #FFD700;
            border-radius: 8px;
            padding: 15px;
            backdrop-filter: blur(5px);
            transition: opacity 0.5s ease-in-out;
            opacity: 1;
        }

        #info-panel.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #FFD700;
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #FFD700;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        button {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid #FFD700;
            color: #FFD700;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-right: 10px;
            margin-bottom: 5px;
            transition: all 0.3s ease;
        }

        button:hover {
            background: rgba(255, 215, 0, 0.2);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        /* Styles for the WebXR button */
        #VRButton {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 12px 24px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            z-index: 10;
        }

        #VRButton:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }

        #VRButton:disabled {
            background-color: #666;
            cursor: not-allowed;
        }

        .value-display {
            font-size: 10px;
            color: #FFA500;
            margin-top: 2px;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            text-align: center;
        }

        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
            text-align: center;
            z-index: 20;
            display: none;
        }

        #easter-egg-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #FFD700;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            display: none;
            z-index: 1000;
        }

        #easter-egg-popup h3 {
            margin-bottom: 10px;
            color: #FFD700;
        }

        #easter-egg-popup .number {
            font-size: 24px;
            color: #FFA500;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="three-canvas"></canvas>
        
        <div id="loading">
            <div>INITIALIZING VR DIGITAL MANHATTAN...</div>
            <div style="margin-top: 10px;">LOADING BITCOIN BLOCKS...</div>
        </div>

        <div id="message-box"></div>

        <div id="controls-panel">
            <div class="control-group">
                <label for="block-count">Block Count</label>
                <input type="range" id="block-count" min="1" max="27000" value="1000" step="1">
                <div class="value-display" id="block-count-value">1000 blocks (10×10×10)</div>
            </div>
            
            <div class="control-group">
                <label for="block-size">Block Size</label>
                <input type="range" id="block-size" min="50" max="200" value="100" step="5">
                <div class="value-display" id="block-size-value">100%</div>
            </div>
            
            <div class="control-group">
                <label for="block-spacing">Block Spacing</label>
                <input type="range" id="block-spacing" min="10" max="100" value="50" step="1">
                <div class="value-display" id="block-spacing-value">50%</div>
            </div>
            
            <div class="control-group">
                <button id="fullscreen-btn">Fullscreen</button>
            </div>
            
            <div class="control-group" style="font-size: 12px; color: #888; margin-top: 10px;">
                <div>VR: Click 'Enter VR' for immersive experience</div>
                <div>Desktop: WASD/Arrow keys • +/- zoom • Mouse drag</div>
            </div>
        </div>

        <div id="info-panel">
            <div>VR Digital Manhattan</div>
            <div style="font-size: 10px; margin-top: 5px;">Bitcoin Visualization</div>
            <div style="font-size: 10px; margin-top: 10px;">
                <div>Camera: <span id="camera-info">Loading...</span></div>
                <div>VR: <span id="vr-status">Checking...</span></div>
            </div>
        </div>

        <div id="easter-egg-popup">
            <h3>Bitcoin Block #</h3>
            <div class="number" id="random-number">1,000,000</div>
            <div style="margin-top: 10px; font-size: 10px;">Click anywhere to close</div>
        </div>
    </div>

    <script type="module">
        // Import the three.js library as a module
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
        // Import WebXR button helper as a module
        import { VRButton } from 'https://unpkg.com/three@0.160.0/examples/jsm/webxr/VRButton.js';

        // Global variables
        let scene, camera, renderer, controls;
        let bitcoinBlocks = [];
        let blockGroup;
        let animationId;
        let isFullscreen = false;
        let xrButton;

        let stars = [];
        
        // Global control variables for keyboard and mouse
        let targetRotationX = 0;
        let targetRotationY = 0;
        let rotationX = 0;
        let rotationY = 0;
        let currentZoom = 0;
        let lastInteractionTime = Date.now();
        
        // Auto-hiding controls system
        let controlsVisible = true;
        let hideControlsTimeout;
        const CONTROLS_HIDE_DELAY = 3000;
        
        // Animation system
        let animationClock;
        let sparkleParticles = [];
        let sparkleGeometry, sparkleMaterial;
        
        // Performance monitoring
        let lastTime = 0;
        let frameCount = 0;

        // Bitcoin Block Generation System
        let currentBlockCount = 1000;
        let currentBlockSize = 1.0;
        let currentBlockSpacing = 0.5;
        let blockGeometry, blockMaterial;

        // Advanced Features System
        let starField;
        let raycaster, mouse;
        let originalCameraPosition;

        /**
         * Displays a message in a custom message box.
         * @param {string} message The message to display.
         * @param {boolean} isError True if it's an error message, false otherwise.
         */
        function showMessageBox(message, isError = false) {
            const msgBox = document.getElementById('message-box');
            msgBox.textContent = message;
            if (isError) {
                msgBox.style.backgroundColor = 'rgba(139, 0, 0, 0.8)';
                msgBox.style.boxShadow = '0 0 15px rgba(255, 0, 0, 0.7)';
            } else {
                msgBox.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                msgBox.style.boxShadow = '0 0 15px rgba(0, 255, 255, 0.7)';
            }
            msgBox.style.display = 'block';
            if (!isError) {
                setTimeout(() => {
                    msgBox.style.display = 'none';
                }, 3000);
            }
        }

        // WebGL Support Detection
        function checkWebGLSupport() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                return !!gl;
            } catch (e) {
                return false;
            }
        }

        function initDigitalManhattan() {
            try {
                console.log('VR Digital Manhattan initializing...');
                
                // Initialize Three.js scene
                initScene();
                initCamera();
                initRenderer();
                initWebXR();
                initLighting();
                initControls();
                
                // Initialize animation system
                initAnimationSystem();
                
                // Generate initial Bitcoin blocks
                generateBitcoinBlocks(1000);
                
                // Initialize UI controls
                initUIControls();
                
                // Start render loop - CRITICAL: Use setAnimationLoop for WebXR
                renderer.setAnimationLoop(animate);
                
                console.log('VR Digital Manhattan initialized successfully!');
                
                // Hide loading screen
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                    showControls();
                }, 500);
                
            } catch (error) {
                console.error('Error initializing VR Digital Manhattan:', error);
                document.getElementById('loading').innerHTML = 
                    '<div style="color: #ff4444;">Initialization Error!</div>' +
                    '<div style="font-size: 12px; margin-top: 10px;">' + error.message + '</div>';
            }
        }

        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011);
            
            blockGroup = new THREE.Group();
            scene.add(blockGroup);
            
            console.log('Scene initialized:', scene);
        }

        function initCamera() {
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            // Start from same perspective as desktop version - outside looking at the cube
            camera.position.set(15, 15, 15); // Same as desktop version
            camera.lookAt(0, 0, 0);
            console.log('Camera initialized at position:', camera.position);
        }

        function initRenderer() {
            const canvas = document.getElementById('three-canvas');
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true,
                alpha: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            console.log('Renderer initialized:', renderer);
        }

        function initWebXR() {
            // Enable XR in the renderer
            renderer.xr.enabled = true;

            // Create the WebXR button and add it to the body
            try {
                xrButton = VRButton.createButton(renderer);
                xrButton.style.position = 'absolute';
                xrButton.style.bottom = '20px';
                xrButton.style.right = '20px';
                xrButton.style.zIndex = '100';
                document.body.appendChild(xrButton);
                showMessageBox("WebXR initialized. Click 'Enter VR' for immersive Bitcoin visualization!");
                document.getElementById('vr-status').textContent = 'Ready';
                console.log('WebXR button created and positioned');
            } catch (error) {
                console.error('WebXR initialization failed:', error);
                showMessageBox("WebXR not supported on this device/browser.", true);
                document.getElementById('vr-status').textContent = 'Not supported';
            }

            // Event listener for when an XR session starts (entering VR)
            renderer.xr.addEventListener('sessionstart', function () {
                showMessageBox("Entering VR Digital Manhattan!");
                console.log('XR Session started - renderer.xr.isPresenting:', renderer.xr.isPresenting);
                document.getElementById('vr-status').textContent = 'Active';
                
                // Hide UI panels in VR
                document.getElementById('controls-panel').style.display = 'none';
                document.getElementById('info-panel').style.display = 'none';
            });

            // Event listener for when an XR session ends (exiting VR)
            renderer.xr.addEventListener('sessionend', function () {
                showMessageBox("Exiting VR Digital Manhattan.");
                console.log('XR Session ended');
                document.getElementById('vr-status').textContent = 'Ready';
                
                // Show UI panels again
                document.getElementById('controls-panel').style.display = 'block';
                document.getElementById('info-panel').style.display = 'block';
            });
        }

        function initLighting() {
            // Enhanced ambient light for VR
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            // Main directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.4);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Golden accent light for brilliant metallic shine
            const goldenLight = new THREE.DirectionalLight(0xFFD700, 1.2);
            goldenLight.position.set(-5, 5, 10);
            scene.add(goldenLight);

            // Point lights for VR depth perception
            const pointLight1 = new THREE.PointLight(0xFFD700, 1.0, 100);
            pointLight1.position.set(0, 20, 0);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xFFA500, 0.8, 80);
            pointLight2.position.set(15, 0, 15);
            scene.add(pointLight2);

            const pointLight3 = new THREE.PointLight(0xFFD700, 0.8, 80);
            pointLight3.position.set(-15, 0, -15);
            scene.add(pointLight3);

            // Additional lights for VR immersion
            const pointLight4 = new THREE.PointLight(0xFFFFFF, 0.6, 60);
            pointLight4.position.set(0, -10, 20);
            scene.add(pointLight4);

            const pointLight5 = new THREE.PointLight(0xFFD700, 0.7, 70);
            pointLight5.position.set(-20, 10, -5);
            scene.add(pointLight5);

            // Add a floor for VR spatial reference
            const floorGeometry = new THREE.PlaneGeometry(100, 100);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x111111,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -10;
            floor.receiveShadow = true;
            scene.add(floor);

            // Add a test cube for VR debugging - positioned near the Bitcoin blocks
            const testCubeGeometry = new THREE.BoxGeometry(1, 1, 1);
            const testCubeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff0000,
                emissive: 0x440000,
                emissiveIntensity: 0.5
            });
            const testCube = new THREE.Mesh(testCubeGeometry, testCubeMaterial);
            testCube.position.set(-8, 8, -8); // Positioned to the side of the Bitcoin cube
            scene.add(testCube);
            console.log('Test cube added at:', testCube.position);
        }

        function initControls() {
            let isMouseDown = false;
            let isTouchActive = false;
            let mouseX = 0;
            let mouseY = 0;
            let initialDistance = 0;
            let autoRotationSpeed = 0.0005;
            
            currentZoom = camera.position.length();

            const canvas = document.getElementById('three-canvas');

            // Mouse controls
            canvas.addEventListener('mousedown', (event) => {
                isMouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
                canvas.style.cursor = 'grabbing';
                onUserInteraction();
            });

            canvas.addEventListener('mousemove', (event) => {
                if (!isMouseDown) return;

                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                targetRotationY += deltaX * 0.01;
                targetRotationX += deltaY * 0.01;

                targetRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, targetRotationX));

                mouseX = event.clientX;
                mouseY = event.clientY;
                onUserInteraction();
            });

            canvas.addEventListener('mouseup', () => {
                isMouseDown = false;
                canvas.style.cursor = 'grab';
            });

            canvas.addEventListener('mouseleave', () => {
                isMouseDown = false;
                canvas.style.cursor = 'grab';
            });

            canvas.style.cursor = 'grab';

            // Mouse wheel zoom
            canvas.addEventListener('wheel', (event) => {
                event.preventDefault();
                const zoomSpeed = 0.08;
                const minDistance = 5;
                const maxDistance = 100;
                
                if (event.deltaY > 0) {
                    currentZoom = Math.min(maxDistance, currentZoom * (1 + zoomSpeed));
                } else {
                    currentZoom = Math.max(minDistance, currentZoom * (1 - zoomSpeed));
                }
                onUserInteraction();
            });

            // Touch controls
            let touches = [];

            canvas.addEventListener('touchstart', (event) => {
                event.preventDefault();
                touches = Array.from(event.touches);
                isTouchActive = true;
                onUserInteraction();

                if (touches.length === 1) {
                    mouseX = touches[0].clientX;
                    mouseY = touches[0].clientY;
                } else if (touches.length === 2) {
                    const dx = touches[0].clientX - touches[1].clientX;
                    const dy = touches[0].clientY - touches[1].clientY;
                    initialDistance = Math.sqrt(dx * dx + dy * dy);
                }
            });

            canvas.addEventListener('touchmove', (event) => {
                event.preventDefault();
                if (!isTouchActive) return;

                touches = Array.from(event.touches);
                onUserInteraction();

                if (touches.length === 1) {
                    const deltaX = touches[0].clientX - mouseX;
                    const deltaY = touches[0].clientY - mouseY;

                    targetRotationY += deltaX * 0.01;
                    targetRotationX += deltaY * 0.01;

                    targetRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, targetRotationX));

                    mouseX = touches[0].clientX;
                    mouseY = touches[0].clientY;
                } else if (touches.length === 2) {
                    const dx = touches[0].clientX - touches[1].clientX;
                    const dy = touches[0].clientY - touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (initialDistance > 0) {
                        const scale = distance / initialDistance;
                        const minDistance = 5;
                        const maxDistance = 100;
                        
                        if (scale > 1.02) {
                            currentZoom = Math.max(minDistance, currentZoom * 0.95);
                            initialDistance = distance;
                        } else if (scale < 0.98) {
                            currentZoom = Math.min(maxDistance, currentZoom * 1.05);
                            initialDistance = distance;
                        }
                    }
                }
            });

            canvas.addEventListener('touchend', (event) => {
                event.preventDefault();
                touches = Array.from(event.touches);
                
                if (touches.length === 0) {
                    isTouchActive = false;
                } else if (touches.length === 1) {
                    mouseX = touches[0].clientX;
                    mouseY = touches[0].clientY;
                    initialDistance = 0;
                }
            });

            function updateControls() {
                const timeSinceInteraction = Date.now() - lastInteractionTime;
                if (timeSinceInteraction > 3000) {
                    targetRotationY += autoRotationSpeed;
                }

                rotationX += (targetRotationX - rotationX) * 0.05;
                rotationY += (targetRotationY - rotationY) * 0.05;

                const currentDistance = camera.position.length();
                const zoomDiff = currentZoom - currentDistance;
                if (Math.abs(zoomDiff) > 0.01) {
                    const newDistance = currentDistance + zoomDiff * 0.1;
                    camera.position.setLength(newDistance);
                }

                camera.position.x = Math.cos(rotationY) * Math.cos(rotationX) * camera.position.length();
                camera.position.y = Math.sin(rotationX) * camera.position.length();
                camera.position.z = Math.sin(rotationY) * Math.cos(rotationX) * camera.position.length();
                camera.lookAt(0, 0, 0);
            }

            window.updateControls = updateControls;
        }

        function initKeyboardControls() {
            document.addEventListener('keydown', (event) => {
                const rotationSpeed = 0.05;
                onUserInteraction();
                
                switch(event.key) {
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        targetRotationY -= rotationSpeed;
                        event.preventDefault();
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        targetRotationY += rotationSpeed;
                        event.preventDefault();
                        break;
                    case 'ArrowUp':
                    case 'w':
                    case 'W':
                        targetRotationX = Math.max(-Math.PI/2, targetRotationX - rotationSpeed);
                        event.preventDefault();
                        break;
                    case 'ArrowDown':
                    case 's':
                    case 'S':
                        targetRotationX = Math.min(Math.PI/2, targetRotationX + rotationSpeed);
                        event.preventDefault();
                        break;
                    case '+':
                    case '=':
                        currentZoom = Math.max(5, currentZoom * 0.9);
                        event.preventDefault();
                        break;
                    case '-':
                    case '_':
                        currentZoom = Math.min(100, currentZoom * 1.1);
                        event.preventDefault();
                        break;
                }
            });
        }

        function createBitcoinBlockMaterial() {
            blockMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFD700,
                metalness: 1.0,
                roughness: 0.02,
                emissive: 0x885500,
                emissiveIntensity: 0.8
            });
            return blockMaterial;
        }

        function calculateCubeDimensions(totalBlocks) {
            const cubeRoot = Math.round(Math.pow(totalBlocks, 1/3));
            const actualBlocks = cubeRoot * cubeRoot * cubeRoot;
            return { dimension: cubeRoot, actualCount: actualBlocks };
        }

        function generateBitcoinBlocks(blockCount) {
            console.log(`Generating ${blockCount} Bitcoin blocks...`);
            
            clearBitcoinBlocks();
            
            const { dimension, actualCount } = calculateCubeDimensions(blockCount);
            currentBlockCount = actualCount;
            
            if (!blockGeometry) {
                blockGeometry = new THREE.BoxGeometry(1, 1, 1);
            }
            if (!blockMaterial) {
                createBitcoinBlockMaterial();
            }
            
            const instancedMesh = new THREE.InstancedMesh(
                blockGeometry,
                blockMaterial,
                actualCount
            );
            instancedMesh.castShadow = true;
            instancedMesh.receiveShadow = true;
            
            const gap = currentBlockSpacing;
            const blockSize = currentBlockSize;
            const totalSize = (dimension - 1) * (blockSize + gap);
            const startPos = -totalSize / 2;
            
            console.log(`Block formation: ${dimension}x${dimension}x${dimension}, totalSize: ${totalSize}, startPos: ${startPos}`);
            
            let index = 0;
            const matrix = new THREE.Matrix4();
            
            for (let x = 0; x < dimension; x++) {
                for (let y = 0; y < dimension; y++) {
                    for (let z = 0; z < dimension; z++) {
                        const posX = startPos + x * (blockSize + gap);
                        const posY = startPos + y * (blockSize + gap);
                        const posZ = startPos + z * (blockSize + gap);
                        
                        matrix.makeScale(blockSize, blockSize, blockSize);
                        matrix.setPosition(posX, posY, posZ);
                        instancedMesh.setMatrixAt(index, matrix);
                        
                        index++;
                    }
                }
            }
            
            instancedMesh.instanceMatrix.needsUpdate = true;
            blockGroup.add(instancedMesh);
            bitcoinBlocks.push(instancedMesh);
            
            updateBlockCountDisplay(actualCount, dimension);
            
            console.log(`Generated ${actualCount} blocks in ${dimension}×${dimension}×${dimension} formation`);
        }

        function clearBitcoinBlocks() {
            bitcoinBlocks.forEach(block => {
                blockGroup.remove(block);
                if (block.geometry) block.geometry.dispose();
                if (block.material) block.material.dispose();
            });
            bitcoinBlocks = [];
        }

        function updateBlockSize(newSize) {
            currentBlockSize = newSize;
            generateBitcoinBlocks(currentBlockCount);
            updateBlockSizeDisplay(newSize);
        }

        function updateBlockSpacing(newSpacing) {
            currentBlockSpacing = newSpacing;
            generateBitcoinBlocks(currentBlockCount);
            updateBlockSpacingDisplay(newSpacing);
        }

        function updateBlockCountDisplay(count, dimension) {
            document.getElementById('block-count-value').textContent = 
                `${count} blocks (${dimension}×${dimension}×${dimension})`;
        }

        function updateBlockSizeDisplay(size) {
            document.getElementById('block-size-value').textContent = `${Math.round(size * 100)}%`;
        }

        function updateBlockSpacingDisplay(spacing) {
            document.getElementById('block-spacing-value').textContent = `${Math.round(spacing * 100)}%`;
        }

        function initAnimationSystem() {
            animationClock = new THREE.Clock();
            createStarField();
            console.log('Animation system initialized');
        }

        function createStarField() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 1000;
            const positions = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount * 3; i += 3) {
                const radius = 200 + Math.random() * 300;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                positions[i] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i + 2] = radius * Math.cos(phi);
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 2,
                sizeAttenuation: false
            });
            
            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }

        function updateAnimations() {
            const elapsedTime = animationClock.getElapsedTime();
            
            if (blockGroup) {
                blockGroup.rotation.y = elapsedTime * 0.0035;
                blockGroup.rotation.x = Math.sin(elapsedTime * 0.001) * 0.02;
                updateGlitterEffect(elapsedTime);
            }
        }

        function updateGlitterEffect(elapsedTime) {
            if (blockMaterial) {
                const baseIntensity = 0.8;
                const sparkle1 = Math.sin(elapsedTime * 0.8) * 0.4;
                const sparkle2 = Math.cos(elapsedTime * 1.2) * 0.3;
                const sparkle3 = Math.sin(elapsedTime * 1.6) * 0.2;
                const sparkle4 = Math.cos(elapsedTime * 2.1) * 0.25;
                const sparkle5 = Math.sin(elapsedTime * 2.7) * 0.15;
                const sparkle6 = Math.cos(elapsedTime * 3.3) * 0.18;
                const glitterIntensity = baseIntensity + sparkle1 + sparkle2 + sparkle3 + sparkle4 + sparkle5 + sparkle6;
                
                const maxBrightness = baseIntensity + 0.4 + 0.3 + 0.2 + 0.25 + 0.15 + 0.18;
                const minBrightness = maxBrightness / 2;
                blockMaterial.emissiveIntensity = Math.max(minBrightness, glitterIntensity);
                
                const goldVariation = Math.sin(elapsedTime * 0.3) * 0.2 + 1.1;
                const sparkleColorShift = Math.sin(elapsedTime * 1.8) * 0.1;
                const redChannel = 1.0;
                const greenChannel = Math.min(1.0, (0.84 * goldVariation) + sparkleColorShift);
                const blueChannel = Math.min(0.4, (0.15 * goldVariation) + (sparkleColorShift * 0.5));
                blockMaterial.color.setRGB(redChannel, greenChannel, blueChannel);
                
                const roughnessBase = 0.02;
                const roughnessSparkle1 = Math.sin(elapsedTime * 1.0) * 0.015;
                const roughnessSparkle2 = Math.cos(elapsedTime * 1.4) * 0.01;
                const roughnessSparkle3 = Math.sin(elapsedTime * 1.8) * 0.008;
                blockMaterial.roughness = Math.max(0.005, roughnessBase + roughnessSparkle1 + roughnessSparkle2 + roughnessSparkle3);
                
                const metallicBase = 0.97;
                const metallicSparkle1 = Math.cos(elapsedTime * 0.9) * 0.03;
                const metallicSparkle2 = Math.sin(elapsedTime * 1.3) * 0.02;
                blockMaterial.metalness = Math.min(1.0, metallicBase + metallicSparkle1 + metallicSparkle2);
            }
        }

        function initUIControls() {
            const blockCountSlider = document.getElementById('block-count');
            const blockSizeSlider = document.getElementById('block-size');
            const blockSpacingSlider = document.getElementById('block-spacing');
            const fullscreenBtn = document.getElementById('fullscreen-btn');

            blockCountSlider.addEventListener('input', (event) => {
                const newCount = parseInt(event.target.value);
                generateBitcoinBlocks(newCount);
                onUserInteraction();
            });

            blockSizeSlider.addEventListener('input', (event) => {
                const newSize = parseInt(event.target.value) / 100;
                updateBlockSize(newSize);
                onUserInteraction();
            });

            blockSpacingSlider.addEventListener('input', (event) => {
                const newSpacing = parseInt(event.target.value) / 100;
                updateBlockSpacing(newSpacing);
                onUserInteraction();
            });

            fullscreenBtn.addEventListener('click', () => {
                toggleFullscreen();
                onUserInteraction();
            });

            initKeyboardControls();
            initEasterEggSystem();
        }

        function initEasterEggSystem() {
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            const canvas = document.getElementById('three-canvas');
            canvas.addEventListener('click', onBlockClick);
        }

        function onBlockClick(event) {
            const rect = event.target.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(bitcoinBlocks);
            
            if (intersects.length > 0) {
                const randomNumber = Math.floor(Math.random() * 21000000) + 1;
                showEasterEgg(randomNumber);
            }
        }

        function showEasterEgg(number) {
            const popup = document.getElementById('easter-egg-popup');
            const numberDisplay = document.getElementById('random-number');
            
            numberDisplay.textContent = number.toLocaleString();
            popup.style.display = 'block';
            
            const hideTimeout = setTimeout(() => {
                popup.style.display = 'none';
            }, 3000);
            
            const closeHandler = () => {
                popup.style.display = 'none';
                clearTimeout(hideTimeout);
                popup.removeEventListener('click', closeHandler);
                document.removeEventListener('click', closeHandler);
            };
            
            popup.addEventListener('click', closeHandler);
            setTimeout(() => {
                document.addEventListener('click', closeHandler);
            }, 100);
        }

        function handleResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateCameraInfo() {
            const distance = Math.round(camera.position.length() * 10) / 10;
            document.getElementById('camera-info').textContent = `Distance: ${distance}`;
        }

        function showControls() {
            if (!controlsVisible) {
                controlsVisible = true;
                document.getElementById('controls-panel').classList.remove('hidden');
                document.getElementById('info-panel').classList.remove('hidden');
            }
            
            if (hideControlsTimeout) {
                clearTimeout(hideControlsTimeout);
            }
            
            hideControlsTimeout = setTimeout(() => {
                hideControls();
            }, CONTROLS_HIDE_DELAY);
        }

        function hideControls() {
            if (controlsVisible) {
                controlsVisible = false;
                document.getElementById('controls-panel').classList.add('hidden');
                document.getElementById('info-panel').classList.add('hidden');
            }
        }

        function onUserInteraction() {
            showControls();
            lastInteractionTime = Date.now();
        }

        function toggleFullscreen() {
            const fullscreenBtn = document.getElementById('fullscreen-btn');
            
            if (!isFullscreen) {
                const element = document.documentElement;
                
                if (element.requestFullscreen) {
                    element.requestFullscreen();
                } else if (element.webkitRequestFullscreen) {
                    element.webkitRequestFullscreen();
                } else if (element.mozRequestFullScreen) {
                    element.mozRequestFullScreen();
                } else if (element.msRequestFullscreen) {
                    element.msRequestFullscreen();
                }
                
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

        function handleFullscreenChange() {
            isFullscreen = !!(document.fullscreenElement || 
                            document.webkitFullscreenElement || 
                            document.mozFullScreenElement || 
                            document.msFullscreenElement);
            
            const fullscreenBtn = document.getElementById('fullscreen-btn');
            fullscreenBtn.textContent = isFullscreen ? 'Exit Fullscreen' : 'Fullscreen';
            
            handleResize();
        }

        function animate() {
            // Update animations
            updateAnimations();
            
            // Update controls (only when not in XR)
            if (window.updateControls && !renderer.xr.isPresenting) {
                window.updateControls();
            }
            
            // Update camera info
            updateCameraInfo();
            
            // Render the scene
            renderer.render(scene, camera);
        }

        // Check for WebXR support with detailed logging
        if ('xr' in navigator) {
            console.log('Navigator.xr detected, checking immersive-vr support...');
            navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                if (supported) {
                    console.log('WebXR VR is supported - immersive-vr sessions available');
                    document.getElementById('vr-status').textContent = 'Supported';
                } else {
                    console.log('WebXR VR is not supported - immersive-vr sessions not available');
                    document.getElementById('vr-status').textContent = 'Not supported';
                    showMessageBox("WebXR VR not supported on this device.", true);
                }
            }).catch((error) => {
                console.error('Error checking WebXR support:', error);
                document.getElementById('vr-status').textContent = 'Error checking';
            });
        } else {
            console.log('WebXR is not available - navigator.xr not found');
            document.getElementById('vr-status').textContent = 'Not available';
            showMessageBox("WebXR not available in this browser.", true);
        }

        // Event listeners
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        window.addEventListener('resize', handleResize);

        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, checking WebGL...');
            
            if (!checkWebGLSupport()) {
                document.getElementById('loading').innerHTML = 
                    '<div style="color: #ff4444;">WebGL not supported!</div>' +
                    '<div style="font-size: 12px; margin-top: 10px;">Please use a modern browser with WebGL support.</div>';
            } else {
                console.log('WebGL supported, initializing VR Digital Manhattan...');
                initDigitalManhattan();
            }
        });
    </script>
</body>
</html> 