<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Palace Cards</title>
    <style>
        /* CSS Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        #app {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
        }

        header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .phase {
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .phase.active {
            display: block;
        }

        .phase.hidden {
            display: none;
        }

        .phase-content {
            padding: 40px;
        }

        .phase-content h2 {
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: #2d3748;
            text-align: center;
        }

        /* Button Base Styles */
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* Enhanced feedback animations */
        @keyframes bounce {
            0%, 20%, 60%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-20px);
            }
            80% {
                transform: translateY(-10px);
            }
        }

        @keyframes shake {
            0%, 100% {
                transform: translateX(0);
            }
            10%, 30%, 50%, 70%, 90% {
                transform: translateX(-5px);
            }
            20%, 40%, 60%, 80% {
                transform: translateX(5px);
            }
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
            100% {
                transform: scale(1);
            }
        }

        /* Feedback message styling */
        .feedback-message {
            position: relative;
            overflow: hidden;
        }

        .feedback-message::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }

        .feedback-message:hover::before {
            left: 100%;
        }

        /* Results phase styling */
        .stat-card {
            text-align: center;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
        }

        #results-table {
            border-collapse: collapse;
        }

        #results-table th {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #results-table td {
            padding: 12px 16px;
            border-bottom: 1px solid #e2e8f0;
            vertical-align: middle;
        }

        #results-table tr:hover {
            background-color: #f8fafc;
        }

        .result-correct {
            background-color: #dcfce7;
            border-left: 4px solid #22c55e;
        }

        .result-incorrect {
            background-color: #fef2f2;
            border-left: 4px solid #ef4444;
        }

        .result-skipped {
            background-color: #fefce8;
            border-left: 4px solid #eab308;
        }

        .card-display {
            font-weight: bold;
            font-size: 1.1em;
            padding: 4px 8px;
            border-radius: 6px;
            display: inline-block;
            min-width: 60px;
            text-align: center;
        }

        .card-display.hearts, .card-display.diamonds {
            color: #dc2626;
            background: #fef2f2;
            border: 1px solid #fecaca;
        }

        .card-display.clubs, .card-display.spades {
            color: #1f2937;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
        }

        .result-badge {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .result-badge.correct {
            background: #dcfce7;
            color: #166534;
            border: 1px solid #22c55e;
        }

        .result-badge.incorrect {
            background: #fef2f2;
            color: #991b1b;
            border: 1px solid #ef4444;
        }

        .result-badge.skipped {
            background: #fefce8;
            color: #a16207;
            border: 1px solid #eab308;
        }

        /* Form Elements */
        input, select {
            padding: 12px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
            background: white;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        /* Responsive Grid and Flexbox Layout System */
        .flex {
            display: flex;
        }

        .flex-col {
            flex-direction: column;
        }

        .flex-row {
            flex-direction: row;
        }

        .items-center {
            align-items: center;
        }

        .justify-center {
            justify-content: center;
        }

        .justify-between {
            justify-content: space-between;
        }

        .gap-2 {
            gap: 0.5rem;
        }

        .gap-4 {
            gap: 1rem;
        }

        .gap-6 {
            gap: 1.5rem;
        }

        .grid {
            display: grid;
        }

        .grid-cols-2 {
            grid-template-columns: repeat(2, 1fr);
        }

        .grid-cols-3 {
            grid-template-columns: repeat(3, 1fr);
        }

        .grid-cols-4 {
            grid-template-columns: repeat(4, 1fr);
        }

        .text-center {
            text-align: center;
        }

        .w-full {
            width: 100%;
        }

        .max-w-md {
            max-width: 28rem;
        }

        .mx-auto {
            margin-left: auto;
            margin-right: auto;
        }

        .mb-4 {
            margin-bottom: 1rem;
        }

        .mb-6 {
            margin-bottom: 1.5rem;
        }

        .p-4 {
            padding: 1rem;
        }

        .p-6 {
            padding: 1.5rem;
        }

        /* Responsive Breakpoints */
        @media (max-width: 768px) {
            #app {
                padding: 15px;
            }

            header h1 {
                font-size: 2rem;
            }

            .phase-content {
                padding: 20px;
            }

            .grid-cols-4 {
                grid-template-columns: repeat(2, 1fr);
            }

            .grid-cols-3 {
                grid-template-columns: repeat(2, 1fr);
            }

            .grid-cols-2 {
                grid-template-columns: 1fr;
            }

            button {
                padding: 10px 20px;
                font-size: 0.9rem;
            }
        }

        @media (max-width: 480px) {
            header h1 {
                font-size: 1.5rem;
            }

            .phase-content {
                padding: 15px;
            }

            .phase-content h2 {
                font-size: 1.4rem;
            }

            button {
                padding: 8px 16px;
                font-size: 0.85rem;
            }
        }

        /* Typography, Colors, and Spacing for Clean Aesthetic */
        .text-sm {
            font-size: 0.875rem;
        }

        .text-base {
            font-size: 1rem;
        }

        .text-lg {
            font-size: 1.125rem;
        }

        .text-xl {
            font-size: 1.25rem;
        }

        .text-2xl {
            font-size: 1.5rem;
        }

        .font-medium {
            font-weight: 500;
        }

        .font-semibold {
            font-weight: 600;
        }

        .font-bold {
            font-weight: 700;
        }

        /* Color System */
        .text-gray-600 {
            color: #718096;
        }

        .text-gray-700 {
            color: #4a5568;
        }

        .text-green-600 {
            color: #38a169;
        }

        .text-red-600 {
            color: #e53e3e;
        }

        .text-blue-600 {
            color: #3182ce;
        }

        .bg-green-50 {
            background-color: #f0fff4;
        }

        .bg-red-50 {
            background-color: #fef5f5;
        }

        .bg-gray-50 {
            background-color: #f9fafb;
        }

        .border-green-200 {
            border-color: #9ae6b4;
        }

        .border-red-200 {
            border-color: #feb2b2;
        }

        .border-gray-200 {
            border-color: #e2e8f0;
        }

        /* Card Display Styles */
        .card-display {
            background: white;
            border: 3px solid #e2e8f0;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            font-size: 3rem;
            font-weight: bold;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }

        .card-display.hearts, .card-display.diamonds {
            color: #e53e3e;
        }

        .card-display.clubs, .card-display.spades {
            color: #2d3748;
        }

        /* Progress Indicator */
        .progress-bar {
            background: #e2e8f0;
            border-radius: 10px;
            height: 8px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        /* Feedback Styles */
        .feedback {
            padding: 12px 20px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 600;
            text-align: center;
        }

        .feedback.correct {
            background: #f0fff4;
            color: #38a169;
            border: 2px solid #9ae6b4;
        }

        .feedback.incorrect {
            background: #fef5f5;
            color: #e53e3e;
            border: 2px solid #feb2b2;
        }

        /* Statistics Display */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .stat-card {
            background: #f9fafb;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #e2e8f0;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #667eea;
            display: block;
        }

        .stat-label {
            font-size: 0.875rem;
            color: #718096;
            margin-top: 5px;
        }

        /* Results Table */
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .results-table th,
        .results-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
        }

        .results-table th {
            background: #f9fafb;
            font-weight: 600;
            color: #4a5568;
        }

        .results-table tr:hover {
            background: #f9fafb;
        }

        .result-correct {
            color: #38a169;
            font-weight: 600;
        }

        .result-incorrect {
            color: #e53e3e;
            font-weight: 600;
        }

        .result-skipped {
            color: #718096;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div id="app">
        <header>
            <h1>Memory Palace Cards</h1>
            <p>Test and improve your memory with playing cards</p>
        </header>

        <!-- Setup Phase -->
        <div id="setup-phase" class="phase active">
            <div class="phase-content">
                <h2>Setup Your Challenge</h2>
                
                <div class="flex flex-col items-center gap-6 max-w-md mx-auto">
                    <!-- Deck Selection -->
                    <div class="w-full">
                        <label for="deck-count" class="block text-lg font-semibold mb-2 text-center">
                            Number of Decks
                        </label>
                        <input 
                            type="number" 
                            id="deck-count" 
                            min="1" 
                            max="10" 
                            value="1" 
                            class="w-full text-center text-xl"
                            placeholder="Enter number of decks (1-10)"
                        >
                        <div id="deck-count-feedback" class="text-center mt-2">
                            <span class="text-gray-600 text-sm">1 deck = 52 cards</span>
                        </div>
                    </div>

                    <!-- Card Count Display -->
                    <div class="text-center">
                        <div class="text-2xl font-bold text-blue-600" id="total-cards-display">52</div>
                        <div class="text-gray-600">Total Cards to Memorize</div>
                    </div>

                    <!-- Instructions -->
                    <div class="text-center text-gray-700 bg-gray-50 p-4 border-gray-200 border rounded-lg">
                        <p class="mb-2">
                            <strong>How to play:</strong>
                        </p>
                        <ol class="text-sm text-left max-w-xs mx-auto">
                            <li>1. Choose number of decks</li>
                            <li>2. Memorize cards one by one</li>
                            <li>3. Test your memory</li>
                            <li>4. See your results!</li>
                        </ol>
                    </div>

                    <!-- Start Button -->
                    <button 
                        id="start-memorization-btn" 
                        class="w-full text-xl py-4 px-8"
                        onclick="handleStartMemorization()"
                    >
                        Start Memorizing Cards
                    </button>

                    <!-- Error Display -->
                    <div id="setup-error" class="w-full text-center" style="display: none;">
                        <!-- Error messages will appear here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Memorization Phase -->
        <div id="memorization-phase" class="phase hidden">
            <div class="phase-content">
                <h2>Memorize the Cards</h2>
                
                <div class="flex flex-col items-center gap-6 max-w-2xl mx-auto">
                    <!-- Progress Information -->
                    <div class="w-full text-center">
                        <!-- Progress Header -->
                        <div class="flex justify-between items-center mb-2">
                            <span class="text-gray-600 font-medium">
                                Card <span id="current-card-number" class="font-bold text-blue-600">1</span> 
                                of <span id="total-card-count" class="font-bold">52</span>
                            </span>
                            <span class="text-gray-600 font-medium">
                                <span id="memorization-progress-percent" class="font-bold text-green-600">0</span>% Complete
                            </span>
                        </div>
                        
                        <!-- Progress Bar -->
                        <div class="progress-bar mb-3">
                            <div id="memorization-progress-fill" class="progress-fill" style="width: 0%;"></div>
                        </div>
                        
                        <!-- Detailed Progress Stats -->
                        <div class="flex justify-center gap-6 text-sm text-gray-600">
                            <div class="flex flex-col items-center">
                                <span class="font-semibold text-blue-600" id="cards-seen">0</span>
                                <span>Cards Seen</span>
                            </div>
                            <div class="flex flex-col items-center">
                                <span class="font-semibold text-gray-500" id="cards-remaining">52</span>
                                <span>Remaining</span>
                            </div>
                            <div class="flex flex-col items-center">
                                <span class="font-semibold text-purple-600" id="time-spent">0:00</span>
                                <span>Time Spent</span>
                            </div>
                        </div>
                    </div>

                    <!-- Card Display Area -->
                    <div class="w-full max-w-md">
                        <div id="memorization-card-display" class="card-display">
                            <!-- Card will be displayed here -->
                        </div>
                    </div>

                    <!-- Card Information -->
                    <div class="text-center">
                        <div class="text-lg text-gray-700 mb-2">
                            Remember this card:
                        </div>
                        <div class="flex flex-col gap-2">
                            <div class="text-xl font-semibold">
                                Suit: <span id="current-card-suit" class="font-bold">Hearts</span>
                            </div>
                            <div class="text-xl font-semibold">
                                Rank: <span id="current-card-rank" class="font-bold">A</span>
                            </div>
                        </div>
                    </div>

                    <!-- Memory Tip -->
                    <div class="bg-blue-50 border-blue-200 border rounded-lg p-4 text-center max-w-md">
                        <div class="text-blue-800 font-semibold mb-1">💡 Memory Tip</div>
                        <div class="text-blue-700 text-sm">
                            Create a mental image or story to remember this card's position and details.
                        </div>
                    </div>

                    <!-- Navigation Controls -->
                    <div id="memorization-navigation" class="w-full max-w-md mx-auto">
                        <!-- Card Navigation -->
                        <div class="flex justify-between items-center gap-4 mb-4">
                            <button 
                                id="prev-card-btn" 
                                class="flex-1 py-3 px-4 bg-gray-100 text-gray-700 border border-gray-300 hover:bg-gray-200"
                                onclick="handlePreviousCard()"
                                disabled
                            >
                                ← Previous
                            </button>
                            
                            <button 
                                id="next-card-btn" 
                                class="flex-1 py-3 px-4"
                                onclick="handleNextCard()"
                            >
                                Next →
                            </button>
                        </div>

                        <!-- Action Buttons -->
                        <div class="flex flex-col gap-3">
                            <button 
                                id="start-testing-btn" 
                                class="w-full py-4 px-6 text-lg font-semibold bg-green-600 hover:bg-green-700 text-white border-none"
                                onclick="handleStartTesting()"
                            >
                                🧠 Start Testing My Memory
                            </button>

                            <button 
                                id="shuffle-cards-btn" 
                                class="w-full py-2 px-4 bg-gray-100 text-gray-700 border border-gray-300 hover:bg-gray-200 text-sm"
                                onclick="handleShuffleCards()"
                            >
                                🔀 Shuffle Cards Again
                            </button>
                        </div>

                        <!-- Quick Jump -->
                        <div class="mt-4 text-center">
                            <label for="jump-to-card" class="block text-sm text-gray-600 mb-2">
                                Jump to card:
                            </label>
                            <div class="flex items-center gap-2 justify-center">
                                <input 
                                    type="number" 
                                    id="jump-to-card" 
                                    min="1" 
                                    max="52" 
                                    class="w-20 text-center text-sm py-1 px-2"
                                    placeholder="1"
                                >
                                <button 
                                    id="jump-btn" 
                                    class="py-1 px-3 text-sm bg-blue-100 text-blue-700 border border-blue-300 hover:bg-blue-200"
                                    onclick="handleJumpToCard()"
                                >
                                    Go
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Testing Phase -->
        <div id="testing-phase" class="phase hidden">
            <div class="phase-content">
                <h2>Test Your Memory</h2>
                
                <div class="flex flex-col items-center gap-6 max-w-2xl mx-auto">
                    <!-- Testing Progress -->
                    <div class="w-full text-center">
                        <div class="flex justify-between items-center mb-2">
                            <span class="text-gray-600 font-medium">
                                Testing Card <span id="testing-card-number" class="font-bold text-blue-600">1</span> 
                                of <span id="testing-total-cards" class="font-bold">52</span>
                            </span>
                            <span class="text-gray-600 font-medium">
                                <span id="testing-progress-percent" class="font-bold text-green-600">0</span>% Complete
                            </span>
                        </div>
                        <div class="progress-bar mb-3">
                            <div id="testing-progress-fill" class="progress-fill" style="width: 0%;"></div>
                        </div>
                        
                        <!-- Testing Statistics -->
                        <div id="testing-stats" class="mt-3 p-3 bg-gray-50 rounded-lg border">
                            <!-- Statistics will be populated by JavaScript -->
                        </div>
                    </div>

                    <!-- Question Area -->
                    <div class="w-full max-w-md text-center">
                        <div class="bg-gray-50 border-2 border-gray-200 rounded-lg p-6 mb-6">
                            <div class="text-lg font-semibold text-gray-700 mb-2">
                                What card was in position <span id="current-position" class="font-bold text-blue-600">1</span>?
                            </div>
                            <div class="text-sm text-gray-500">
                                Select the suit and rank of the card you remember
                            </div>
                        </div>
                    </div>

                    <!-- Answer Selection -->
                    <div class="w-full max-w-md">
                        <div class="grid grid-cols-1 gap-4">
                            <!-- Suit Selection -->
                            <div>
                                <label for="suit-select" class="block text-lg font-semibold mb-2 text-center">
                                    Suit
                                </label>
                                <select 
                                    id="suit-select" 
                                    class="w-full text-center text-lg py-3 px-4"
                                    onchange="handleSuitSelection()"
                                >
                                    <option value="">Select Suit</option>
                                    <!-- Options will be populated by JavaScript -->
                                </select>
                            </div>

                            <!-- Rank Selection (initially disabled) -->
                            <div>
                                <label for="rank-select" class="block text-lg font-semibold mb-2 text-center">
                                    Rank
                                </label>
                                <select 
                                    id="rank-select" 
                                    class="w-full text-center text-lg py-3 px-4" 
                                    disabled
                                    onchange="handleRankSelection()"
                                >
                                    <option value="">Select Rank</option>
                                    <!-- Options will be populated by JavaScript -->
                                </select>
                            </div>
                        </div>

                        <!-- Action Buttons -->
                        <div class="flex flex-col gap-3 mt-6">
                            <button 
                                id="submit-answer-btn" 
                                class="w-full py-3 px-6 text-lg font-semibold bg-green-600 hover:bg-green-700 text-white border-none"
                                onclick="handleSubmitAnswer()"
                                disabled
                            >
                                Submit Answer
                            </button>

                            <div class="flex gap-3">
                                <button 
                                    id="skip-card-btn" 
                                    class="flex-1 py-2 px-4 bg-gray-100 text-gray-700 border border-gray-300 hover:bg-gray-200"
                                    onclick="handleSkipCard()"
                                >
                                    Skip This Card
                                </button>

                                <button 
                                    id="finish-testing-btn" 
                                    class="flex-1 py-2 px-4 bg-red-100 text-red-700 border border-red-300 hover:bg-red-200"
                                    onclick="handleFinishTesting()"
                                >
                                    Finish Test
                                </button>
                            </div>
                        </div>

                        <!-- Feedback Area -->
                        <div id="testing-feedback" class="mt-4">
                            <!-- Feedback messages will appear here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Results Phase -->
        <div id="results-phase" class="phase hidden">
            <div class="phase-content">
                <h2>🎉 Your Memory Palace Results</h2>
                
                <!-- Overall Statistics Summary -->
                <div id="results-summary" class="mb-8">
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-6 mb-6">
                        <div class="stat-card bg-gradient-to-br from-blue-50 to-blue-100 p-6 rounded-xl border-2 border-blue-200">
                            <div class="text-3xl font-bold text-blue-600" id="total-cards-stat">0</div>
                            <div class="text-sm text-blue-700 font-medium">Total Cards</div>
                        </div>
                        <div class="stat-card bg-gradient-to-br from-green-50 to-green-100 p-6 rounded-xl border-2 border-green-200">
                            <div class="text-3xl font-bold text-green-600" id="correct-answers-stat">0</div>
                            <div class="text-sm text-green-700 font-medium">Correct Answers</div>
                        </div>
                        <div class="stat-card bg-gradient-to-br from-red-50 to-red-100 p-6 rounded-xl border-2 border-red-200">
                            <div class="text-3xl font-bold text-red-600" id="incorrect-answers-stat">0</div>
                            <div class="text-sm text-red-700 font-medium">Incorrect Answers</div>
                        </div>
                        <div class="stat-card bg-gradient-to-br from-yellow-50 to-yellow-100 p-6 rounded-xl border-2 border-yellow-200">
                            <div class="text-3xl font-bold text-yellow-600" id="skipped-answers-stat">0</div>
                            <div class="text-sm text-yellow-700 font-medium">Skipped Cards</div>
                        </div>
                    </div>
                    
                    <!-- Accuracy Display -->
                    <div class="text-center mb-6">
                        <div class="inline-block bg-gradient-to-r from-purple-100 to-pink-100 px-8 py-4 rounded-2xl border-2 border-purple-200">
                            <div class="text-5xl font-bold text-purple-600 mb-2" id="accuracy-percentage">0%</div>
                            <div class="text-lg text-purple-700 font-semibold">Overall Accuracy</div>
                        </div>
                    </div>
                </div>

                <!-- Detailed Results Table -->
                <div class="mb-8">
                    <h3 class="text-xl font-semibold mb-4 text-gray-700">Detailed Results</h3>
                    <div class="overflow-x-auto bg-white rounded-lg shadow-lg border">
                        <table id="results-table" class="w-full">
                            <thead class="bg-gray-50 border-b-2 border-gray-200">
                                <tr>
                                    <th class="px-4 py-3 text-left text-sm font-semibold text-gray-600">Position</th>
                                    <th class="px-4 py-3 text-left text-sm font-semibold text-gray-600">Correct Card</th>
                                    <th class="px-4 py-3 text-left text-sm font-semibold text-gray-600">Your Answer</th>
                                    <th class="px-4 py-3 text-center text-sm font-semibold text-gray-600">Result</th>
                                </tr>
                            </thead>
                            <tbody id="results-table-body">
                                <!-- Table rows will be populated by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Performance Analysis -->
                <div class="mb-8">
                    <h3 class="text-xl font-semibold mb-4 text-gray-700">Performance Analysis</h3>
                    <div id="performance-analysis" class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <!-- Analysis content will be populated by JavaScript -->
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="flex flex-col md:flex-row gap-4 justify-center">
                    <button 
                        id="new-game-btn" 
                        class="px-8 py-3 bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-700 hover:to-purple-700 text-white font-semibold rounded-lg shadow-lg transform hover:scale-105 transition-all duration-200"
                        onclick="startNewGame()"
                    >
                        🎮 Start New Game
                    </button>
                    <button 
                        id="retry-same-cards-btn" 
                        class="px-8 py-3 bg-gradient-to-r from-green-600 to-teal-600 hover:from-green-700 hover:to-teal-700 text-white font-semibold rounded-lg shadow-lg transform hover:scale-105 transition-all duration-200"
                        onclick="retryWithSameCards()"
                    >
                        🔄 Retry Same Cards
                    </button>
                    <button 
                        id="export-results-btn" 
                        class="px-8 py-3 bg-gradient-to-r from-gray-600 to-gray-700 hover:from-gray-700 hover:to-gray-800 text-white font-semibold rounded-lg shadow-lg transform hover:scale-105 transition-all duration-200"
                        onclick="exportResults()"
                    >
                        📊 Export Results
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Memory Palace Cards Application
        
        // Card object structure and constants
        const SUITS = ['Hearts', 'Diamonds', 'Clubs', 'Spades'];
        const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const SUIT_SYMBOLS = {
            'Hearts': '♥',
            'Diamonds': '♦',
            'Clubs': '♣',
            'Spades': '♠'
        };

        // Card class to represent individual playing cards
        class Card {
            constructor(suit, rank, position = 0) {
                this.suit = suit;
                this.rank = rank;
                this.position = position;
                this.symbol = SUIT_SYMBOLS[suit];
            }

            // Get display string for the card
            getDisplayString() {
                return `${this.rank}${this.symbol}`;
            }

            // Get suit class for CSS styling
            getSuitClass() {
                return this.suit.toLowerCase();
            }

            // Check if this card matches another card
            matches(otherCard) {
                return this.suit === otherCard.suit && this.rank === otherCard.rank;
            }

            // Compare cards for equality
            equals(suit, rank) {
                return this.suit === suit && this.rank === rank;
            }

            // Get card as object for storage/comparison
            toObject() {
                return {
                    suit: this.suit,
                    rank: this.rank,
                    position: this.position,
                    symbol: this.symbol
                };
            }

            // Create card from object
            static fromObject(obj) {
                return new Card(obj.suit, obj.rank, obj.position);
            }
        }

        // Game state management object
        const gameState = {
            // Current phase of the game
            phase: 'setup', // setup, memorization, testing, results
            
            // Game configuration
            numDecks: 1,
            totalCards: 0,
            
            // Card arrays
            cards: [], // Array of Card objects
            currentCardIndex: 0,
            
            // User responses
            userAnswers: [], // Array of {suit, rank, isCorrect, isSkipped}
            
            // Testing phase state
            testingIndex: 0,
            
            // Statistics
            stats: {
                totalCards: 0,
                correctAnswers: 0,
                incorrectAnswers: 0,
                skippedAnswers: 0,
                correctPercentage: 0
            },

            // Reset game state
            reset() {
                this.phase = 'setup';
                this.numDecks = 1;
                this.totalCards = 0;
                this.cards = [];
                this.currentCardIndex = 0;
                this.userAnswers = [];
                this.testingIndex = 0;
                this.stats = {
                    totalCards: 0,
                    correctAnswers: 0,
                    incorrectAnswers: 0,
                    skippedAnswers: 0,
                    correctPercentage: 0
                };
            },

            // Calculate statistics
            calculateStats() {
                this.stats.totalCards = this.cards.length;
                this.stats.correctAnswers = this.userAnswers.filter(answer => answer.isCorrect).length;
                this.stats.incorrectAnswers = this.userAnswers.filter(answer => !answer.isCorrect && !answer.isSkipped).length;
                this.stats.skippedAnswers = this.userAnswers.filter(answer => answer.isSkipped).length;
                
                if (this.stats.totalCards > 0) {
                    this.stats.correctPercentage = Math.round((this.stats.correctAnswers / this.stats.totalCards) * 100);
                } else {
                    this.stats.correctPercentage = 0;
                }
            }
        };

        // Deck generation functions
        
        // Generate a single standard 52-card deck
        function generateSingleDeck() {
            const deck = [];
            let position = 0;
            
            for (const suit of SUITS) {
                for (const rank of RANKS) {
                    deck.push(new Card(suit, rank, position));
                    position++;
                }
            }
            
            return deck;
        }

        // Generate multiple decks based on specified number
        function generateDecks(numDecks = 1) {
            if (numDecks < 1 || numDecks > 10) {
                throw new Error('Number of decks must be between 1 and 10');
            }
            
            const allCards = [];
            let globalPosition = 0;
            
            for (let deckIndex = 0; deckIndex < numDecks; deckIndex++) {
                for (const suit of SUITS) {
                    for (const rank of RANKS) {
                        const card = new Card(suit, rank, globalPosition);
                        allCards.push(card);
                        globalPosition++;
                    }
                }
            }
            
            return allCards;
        }

        // Initialize a new game with specified number of decks
        function initializeGame(numDecks) {
            try {
                // Reset game state
                gameState.reset();
                
                // Set configuration
                gameState.numDecks = numDecks;
                
                // Generate cards
                gameState.cards = generateDecks(numDecks);
                gameState.totalCards = gameState.cards.length;
                
                // Initialize user answers array with empty responses
                gameState.userAnswers = gameState.cards.map(() => ({
                    suit: null,
                    rank: null,
                    isCorrect: false,
                    isSkipped: false
                }));
                
                console.log(`Game initialized with ${numDecks} deck(s), ${gameState.totalCards} total cards`);
                return true;
                
            } catch (error) {
                console.error('Error initializing game:', error);
                return false;
            }
        }

        // Validate deck configuration
        function validateDeckCount(numDecks) {
            const num = parseInt(numDecks);
            
            if (isNaN(num)) {
                return { valid: false, message: 'Please enter a valid number' };
            }
            
            if (num < 1) {
                return { valid: false, message: 'Must have at least 1 deck' };
            }
            
            if (num > 10) {
                return { valid: false, message: 'Maximum 10 decks allowed' };
            }
            
            return { valid: true, message: '' };
        }

        // Get card count for given number of decks
        function getCardCount(numDecks) {
            return numDecks * 52;
        }

        // Card shuffling functions
        
        // Fisher-Yates shuffle algorithm for randomizing card order
        function shuffleArray(array) {
            const shuffled = [...array]; // Create a copy to avoid mutating original
            
            for (let i = shuffled.length - 1; i > 0; i--) {
                // Generate random index from 0 to i
                const randomIndex = Math.floor(Math.random() * (i + 1));
                
                // Swap elements at i and randomIndex
                [shuffled[i], shuffled[randomIndex]] = [shuffled[randomIndex], shuffled[i]];
            }
            
            return shuffled;
        }

        // Shuffle the cards in the game state
        function shuffleCards() {
            if (gameState.cards.length === 0) {
                console.warn('No cards to shuffle');
                return false;
            }
            
            // Shuffle the cards array
            gameState.cards = shuffleArray(gameState.cards);
            
            // Update positions after shuffling
            gameState.cards.forEach((card, index) => {
                card.position = index;
            });
            
            // Reset user answers to match new card order
            gameState.userAnswers = gameState.cards.map(() => ({
                suit: null,
                rank: null,
                isCorrect: false,
                isSkipped: false
            }));
            
            // Reset current card index
            gameState.currentCardIndex = 0;
            gameState.testingIndex = 0;
            
            console.log('Cards shuffled successfully');
            return true;
        }

        // Initialize game with shuffled cards
        function initializeShuffledGame(numDecks) {
            const success = initializeGame(numDecks);
            
            if (success) {
                shuffleCards();
                console.log(`Game initialized and shuffled with ${numDecks} deck(s)`);
            }
            
            return success;
        }

        // Seed-based shuffle for reproducible results (useful for testing)
        function seededShuffle(array, seed) {
            const shuffled = [...array];
            let currentSeed = seed;
            
            // Simple linear congruential generator for seeded randomness
            function seededRandom() {
                currentSeed = (currentSeed * 9301 + 49297) % 233280;
                return currentSeed / 233280;
            }
            
            for (let i = shuffled.length - 1; i > 0; i--) {
                const randomIndex = Math.floor(seededRandom() * (i + 1));
                [shuffled[i], shuffled[randomIndex]] = [shuffled[randomIndex], shuffled[i]];
            }
            
            return shuffled;
        }

        // Shuffle cards with a specific seed (for testing/reproducibility)
        function shuffleCardsWithSeed(seed) {
            if (gameState.cards.length === 0) {
                console.warn('No cards to shuffle');
                return false;
            }
            
            gameState.cards = seededShuffle(gameState.cards, seed);
            
            // Update positions after shuffling
            gameState.cards.forEach((card, index) => {
                card.position = index;
            });
            
            // Reset user answers
            gameState.userAnswers = gameState.cards.map(() => ({
                suit: null,
                rank: null,
                isCorrect: false,
                isSkipped: false
            }));
            
            gameState.currentCardIndex = 0;
            gameState.testingIndex = 0;
            
            console.log(`Cards shuffled with seed ${seed}`);
            return true;
        }

        // Verify shuffle quality (for testing purposes)
        function verifyShuffleQuality(originalArray, shuffledArray) {
            if (originalArray.length !== shuffledArray.length) {
                return { valid: false, message: 'Array lengths do not match' };
            }
            
            // Check if all elements are present
            const originalSet = new Set(originalArray.map(card => card.getDisplayString()));
            const shuffledSet = new Set(shuffledArray.map(card => card.getDisplayString()));
            
            if (originalSet.size !== shuffledSet.size) {
                return { valid: false, message: 'Card count mismatch after shuffle' };
            }
            
            // Check if order has changed
            let samePositions = 0;
            for (let i = 0; i < originalArray.length; i++) {
                if (originalArray[i].getDisplayString() === shuffledArray[i].getDisplayString()) {
                    samePositions++;
                }
            }
            
            const changePercentage = ((originalArray.length - samePositions) / originalArray.length) * 100;
            
            return {
                valid: true,
                message: `Shuffle quality: ${changePercentage.toFixed(1)}% of cards changed position`,
                changePercentage: changePercentage
            };
        }

        // Session state management functions
        
        // Phase management
        function setPhase(newPhase) {
            const validPhases = ['setup', 'memorization', 'testing', 'results'];
            
            if (!validPhases.includes(newPhase)) {
                console.error(`Invalid phase: ${newPhase}`);
                return false;
            }
            
            const oldPhase = gameState.phase;
            gameState.phase = newPhase;
            
            // Update UI to show correct phase
            updatePhaseDisplay();
            
            console.log(`Phase changed from ${oldPhase} to ${newPhase}`);
            return true;
        }

        // Update UI to show the current phase
        function updatePhaseDisplay() {
            // Hide all phases
            document.querySelectorAll('.phase').forEach(phase => {
                phase.classList.remove('active');
                phase.classList.add('hidden');
            });
            
            // Show current phase
            const currentPhaseElement = document.getElementById(`${gameState.phase}-phase`);
            if (currentPhaseElement) {
                currentPhaseElement.classList.remove('hidden');
                currentPhaseElement.classList.add('active');
            }
        }

        // Progress management
        function getMemorizationProgress() {
            if (gameState.cards.length === 0) return 0;
            return Math.round((gameState.currentCardIndex / gameState.cards.length) * 100);
        }

        function getTestingProgress() {
            if (gameState.cards.length === 0) return 0;
            return Math.round((gameState.testingIndex / gameState.cards.length) * 100);
        }

        function getCurrentCard() {
            if (gameState.phase === 'memorization') {
                return gameState.cards[gameState.currentCardIndex] || null;
            } else if (gameState.phase === 'testing') {
                return gameState.cards[gameState.testingIndex] || null;
            }
            return null;
        }

        // Navigation functions
        function nextCard() {
            if (gameState.phase === 'memorization') {
                if (gameState.currentCardIndex < gameState.cards.length - 1) {
                    gameState.currentCardIndex++;
                    return true;
                }
            }
            return false;
        }

        function previousCard() {
            if (gameState.phase === 'memorization') {
                if (gameState.currentCardIndex > 0) {
                    gameState.currentCardIndex--;
                    return true;
                }
            }
            return false;
        }

        function canGoNext() {
            return gameState.phase === 'memorization' && 
                   gameState.currentCardIndex < gameState.cards.length - 1;
        }

        function canGoPrevious() {
            return gameState.phase === 'memorization' && 
                   gameState.currentCardIndex > 0;
        }

        // Answer management
        function submitAnswer(suit, rank) {
            if (gameState.phase !== 'testing') {
                console.error('Cannot submit answer outside of testing phase');
                return false;
            }

            if (gameState.testingIndex >= gameState.cards.length) {
                console.error('Testing index out of bounds');
                return false;
            }

            const currentCard = gameState.cards[gameState.testingIndex];
            const isCorrect = currentCard.equals(suit, rank);

            // Store the user's answer
            gameState.userAnswers[gameState.testingIndex] = {
                suit: suit,
                rank: rank,
                isCorrect: isCorrect,
                isSkipped: false
            };

            console.log(`Answer submitted for card ${gameState.testingIndex + 1}: ${rank} of ${suit} - ${isCorrect ? 'Correct' : 'Incorrect'}`);
            
            return {
                isCorrect: isCorrect,
                correctCard: currentCard,
                userAnswer: { suit, rank }
            };
        }

        function skipAnswer() {
            if (gameState.phase !== 'testing') {
                console.error('Cannot skip answer outside of testing phase');
                return false;
            }

            if (gameState.testingIndex >= gameState.cards.length) {
                console.error('Testing index out of bounds');
                return false;
            }

            // Store the skip
            gameState.userAnswers[gameState.testingIndex] = {
                suit: null,
                rank: null,
                isCorrect: false,
                isSkipped: true
            };

            console.log(`Answer skipped for card ${gameState.testingIndex + 1}`);
            return true;
        }

        function nextTestCard() {
            if (gameState.phase === 'testing') {
                if (gameState.testingIndex < gameState.cards.length - 1) {
                    gameState.testingIndex++;
                    return true;
                } else {
                    // Testing complete, move to results
                    finishTesting();
                    return false;
                }
            }
            return false;
        }

        function isTestingComplete() {
            return gameState.testingIndex >= gameState.cards.length - 1;
        }

        // Session control functions
        function startMemorization(numDecks) {
            if (!initializeShuffledGame(numDecks)) {
                return false;
            }
            
            setPhase('memorization');
            gameState.currentCardIndex = 0;
            return true;
        }

        // Removed duplicate startTesting function - using enhanced version later in code

        function finishTesting() {
            gameState.calculateStats();
            setPhase('results');
            console.log('Testing completed, showing results');
        }

        function resetGame() {
            gameState.reset();
            setPhase('setup');
            console.log('Game reset to setup phase');
        }

        // Session persistence (in memory only)
        function getSessionSummary() {
            return {
                phase: gameState.phase,
                numDecks: gameState.numDecks,
                totalCards: gameState.totalCards,
                currentCardIndex: gameState.currentCardIndex,
                testingIndex: gameState.testingIndex,
                answeredCount: gameState.userAnswers.filter(a => a.suit !== null || a.isSkipped).length,
                stats: { ...gameState.stats }
            };
        }

        function isSessionActive() {
            return gameState.phase !== 'setup' && gameState.cards.length > 0;
        }

        // Utility functions for card display and comparison
        
        // Card display utilities
        function formatCardDisplay(card) {
            if (!card) return '';
            return `${card.rank}${card.symbol}`;
        }

        function getCardColorClass(card) {
            if (!card) return '';
            return (card.suit === 'Hearts' || card.suit === 'Diamonds') ? 'text-red-600' : 'text-gray-700';
        }

        function createCardElement(card, additionalClasses = '') {
            if (!card) return null;
            
            const cardDiv = document.createElement('div');
            cardDiv.className = `card-display ${card.getSuitClass()} ${additionalClasses}`;
            cardDiv.textContent = card.getDisplayString();
            
            return cardDiv;
        }

        function updateCardDisplay(elementId, card) {
            const element = document.getElementById(elementId);
            if (!element || !card) return false;
            
            element.textContent = card.getDisplayString();
            element.className = `card-display ${card.getSuitClass()}`;
            
            return true;
        }

        // Progress display utilities
        function updateProgressBar(elementId, percentage) {
            const progressBar = document.getElementById(elementId);
            if (!progressBar) return false;
            
            const progressFill = progressBar.querySelector('.progress-fill');
            if (progressFill) {
                progressFill.style.width = `${percentage}%`;
            }
            
            return true;
        }

        function createProgressBar(percentage = 0) {
            const progressContainer = document.createElement('div');
            progressContainer.className = 'progress-bar';
            
            const progressFill = document.createElement('div');
            progressFill.className = 'progress-fill';
            progressFill.style.width = `${percentage}%`;
            
            progressContainer.appendChild(progressFill);
            return progressContainer;
        }

        // Comparison utilities
        function compareCards(card1, card2) {
            if (!card1 || !card2) return false;
            return card1.matches(card2);
        }

        function findCardDifferences(userCard, correctCard) {
            const differences = [];
            
            if (!userCard || !correctCard) {
                return ['Invalid card data'];
            }
            
            if (userCard.suit !== correctCard.suit) {
                differences.push(`Suit: You said ${userCard.suit}, correct is ${correctCard.suit}`);
            }
            
            if (userCard.rank !== correctCard.rank) {
                differences.push(`Rank: You said ${userCard.rank}, correct is ${correctCard.rank}`);
            }
            
            return differences;
        }

        function validateCardInput(suit, rank) {
            const errors = [];
            
            if (!suit || !SUITS.includes(suit)) {
                errors.push('Please select a valid suit');
            }
            
            if (!rank || !RANKS.includes(rank)) {
                errors.push('Please select a valid rank');
            }
            
            return {
                isValid: errors.length === 0,
                errors: errors
            };
        }

        // Dropdown population utilities
        function populateSuitDropdown(selectElement) {
            if (!selectElement) return false;
            
            // Clear existing options
            selectElement.innerHTML = '<option value="">Select Suit</option>';
            
            SUITS.forEach(suit => {
                const option = document.createElement('option');
                option.value = suit;
                option.textContent = `${suit} ${SUIT_SYMBOLS[suit]}`;
                selectElement.appendChild(option);
            });
            
            return true;
        }

        function populateRankDropdown(selectElement) {
            if (!selectElement) return false;
            
            // Clear existing options
            selectElement.innerHTML = '<option value="">Select Rank</option>';
            
            RANKS.forEach(rank => {
                const option = document.createElement('option');
                option.value = rank;
                option.textContent = rank;
                selectElement.appendChild(option);
            });
            
            return true;
        }

        // Feedback display utilities
        function createFeedbackElement(isCorrect, message = '') {
            const feedback = document.createElement('div');
            feedback.className = `feedback ${isCorrect ? 'correct' : 'incorrect'}`;
            
            const icon = isCorrect ? '✓' : '✗';
            const defaultMessage = isCorrect ? 'Correct!' : 'Incorrect';
            
            feedback.textContent = `${icon} ${message || defaultMessage}`;
            
            return feedback;
        }

        function showFeedback(containerId, isCorrect, message = '', duration = 3000) {
            const container = document.getElementById(containerId);
            if (!container) return false;
            
            // Remove existing feedback
            const existingFeedback = container.querySelector('.feedback');
            if (existingFeedback) {
                existingFeedback.remove();
            }
            
            // Add new feedback
            const feedback = createFeedbackElement(isCorrect, message);
            container.appendChild(feedback);
            
            // Auto-remove after duration
            if (duration > 0) {
                setTimeout(() => {
                    if (feedback.parentNode) {
                        feedback.remove();
                    }
                }, duration);
            }
            
            return true;
        }

        // Statistics display utilities
        function formatPercentage(value) {
            return `${Math.round(value)}%`;
        }

        function createStatCard(label, value, isPercentage = false) {
            const statCard = document.createElement('div');
            statCard.className = 'stat-card';
            
            const statValue = document.createElement('span');
            statValue.className = 'stat-value';
            statValue.textContent = isPercentage ? formatPercentage(value) : value;
            
            const statLabel = document.createElement('div');
            statLabel.className = 'stat-label';
            statLabel.textContent = label;
            
            statCard.appendChild(statValue);
            statCard.appendChild(statLabel);
            
            return statCard;
        }

        function updateStatCard(cardElement, value, isPercentage = false) {
            if (!cardElement) return false;
            
            const statValue = cardElement.querySelector('.stat-value');
            if (statValue) {
                statValue.textContent = isPercentage ? formatPercentage(value) : value;
            }
            
            return true;
        }

        // Results table utilities
        function createResultRow(index, card, userAnswer) {
            const row = document.createElement('tr');
            
            // Position column
            const positionCell = document.createElement('td');
            positionCell.textContent = index + 1;
            row.appendChild(positionCell);
            
            // Correct card column
            const correctCardCell = document.createElement('td');
            correctCardCell.textContent = card.getDisplayString();
            correctCardCell.className = getCardColorClass(card);
            row.appendChild(correctCardCell);
            
            // User answer column
            const userAnswerCell = document.createElement('td');
            if (userAnswer.isSkipped) {
                userAnswerCell.textContent = 'Skipped';
                userAnswerCell.className = 'result-skipped';
            } else {
                const userCard = new Card(userAnswer.suit, userAnswer.rank);
                userAnswerCell.textContent = userCard.getDisplayString();
                userAnswerCell.className = userAnswer.isCorrect ? 'result-correct' : 'result-incorrect';
            }
            row.appendChild(userAnswerCell);
            
            // Result column
            const resultCell = document.createElement('td');
            if (userAnswer.isSkipped) {
                resultCell.textContent = 'Skipped';
                resultCell.className = 'result-skipped';
            } else {
                resultCell.textContent = userAnswer.isCorrect ? 'Correct' : 'Incorrect';
                resultCell.className = userAnswer.isCorrect ? 'result-correct' : 'result-incorrect';
            }
            row.appendChild(resultCell);
            
            return row;
        }

        // Enhanced Animation utilities for smooth card transitions
        function fadeIn(element, duration = 300) {
            if (!element) return Promise.resolve();
            
            return new Promise(resolve => {
                element.style.opacity = '0';
                element.style.transform = 'scale(0.95)';
                element.style.transition = `opacity ${duration}ms ease-out, transform ${duration}ms ease-out`;
                
                requestAnimationFrame(() => {
                    element.style.opacity = '1';
                    element.style.transform = 'scale(1)';
                });
                
                setTimeout(resolve, duration);
            });
        }

        function fadeOut(element, duration = 300) {
            if (!element) return Promise.resolve();
            
            return new Promise(resolve => {
                element.style.transition = `opacity ${duration}ms ease-in, transform ${duration}ms ease-in`;
                element.style.opacity = '0';
                element.style.transform = 'scale(0.95)';
                
                setTimeout(resolve, duration);
            });
        }

        function slideIn(element, direction = 'right', duration = 400) {
            if (!element) return Promise.resolve();
            
            const translateStart = direction === 'right' ? 'translateX(50px)' : 
                                 direction === 'left' ? 'translateX(-50px)' :
                                 direction === 'up' ? 'translateY(-30px)' : 'translateY(30px)';
            
            return new Promise(resolve => {
                element.style.opacity = '0';
                element.style.transform = translateStart;
                element.style.transition = `opacity ${duration}ms ease-out, transform ${duration}ms cubic-bezier(0.34, 1.56, 0.64, 1)`;
                
                requestAnimationFrame(() => {
                    element.style.opacity = '1';
                    element.style.transform = 'translateX(0) translateY(0)';
                });
                
                setTimeout(resolve, duration);
            });
        }

        function slideOut(element, direction = 'left', duration = 300) {
            if (!element) return Promise.resolve();
            
            const translateEnd = direction === 'left' ? 'translateX(-50px)' : 
                               direction === 'right' ? 'translateX(50px)' :
                               direction === 'up' ? 'translateY(-30px)' : 'translateY(30px)';
            
            return new Promise(resolve => {
                element.style.transition = `opacity ${duration}ms ease-in, transform ${duration}ms ease-in`;
                element.style.opacity = '0';
                element.style.transform = translateEnd;
                
                setTimeout(resolve, duration);
            });
        }

        function bounceIn(element, duration = 600) {
            if (!element) return Promise.resolve();
            
            return new Promise(resolve => {
                element.style.opacity = '0';
                element.style.transform = 'scale(0.3)';
                element.style.transition = `opacity ${duration}ms ease-out, transform ${duration}ms cubic-bezier(0.68, -0.55, 0.265, 1.55)`;
                
                requestAnimationFrame(() => {
                    element.style.opacity = '1';
                    element.style.transform = 'scale(1)';
                });
                
                setTimeout(resolve, duration);
            });
        }

        function flipCard(element, duration = 600) {
            if (!element) return Promise.resolve();
            
            return new Promise(resolve => {
                // First half of flip - rotate to 90 degrees
                element.style.transition = `transform ${duration/2}ms ease-in`;
                element.style.transform = 'rotateY(90deg)';
                
                setTimeout(() => {
                    // Update content in the middle of the flip
                    // Content will be updated by calling function
                    
                    // Second half of flip - rotate back to 0 degrees
                    element.style.transition = `transform ${duration/2}ms ease-out`;
                    element.style.transform = 'rotateY(0deg)';
                    
                    setTimeout(resolve, duration/2);
                }, duration/2);
            });
        }

        // Setup phase event handlers
        
        function handleStartMemorization() {
            const deckCountInput = document.getElementById('deck-count');
            const numDecks = parseInt(deckCountInput.value);
            
            // Validate input
            const validation = validateDeckCount(numDecks);
            if (!validation.valid) {
                showSetupError(validation.message);
                return;
            }
            
            // Clear any existing errors
            hideSetupError();
            
            // Disable button to prevent double-clicks
            const startBtn = document.getElementById('start-memorization-btn');
            startBtn.disabled = true;
            startBtn.textContent = 'Initializing...';
            
            // Start the memorization phase
            setTimeout(() => {
                const success = startMemorization(numDecks);
                
                if (success) {
                    // Update memorization interface
                    updateMemorizationInterface();
                } else {
                    showSetupError('Failed to initialize game. Please try again.');
                    startBtn.disabled = false;
                    startBtn.textContent = 'Start Memorizing Cards';
                }
            }, 100);
        }

        function showSetupError(message) {
            const errorDiv = document.getElementById('setup-error');
            if (errorDiv) {
                errorDiv.innerHTML = `<div class="feedback incorrect">${message}</div>`;
                errorDiv.style.display = 'block';
            }
        }

        function hideSetupError() {
            const errorDiv = document.getElementById('setup-error');
            if (errorDiv) {
                errorDiv.style.display = 'none';
                errorDiv.innerHTML = '';
            }
        }

        function updateCardCountDisplay() {
            const deckCountInput = document.getElementById('deck-count');
            const totalCardsDisplay = document.getElementById('total-cards-display');
            const feedbackDiv = document.getElementById('deck-count-feedback');
            
            const numDecks = parseInt(deckCountInput.value) || 1;
            const totalCards = getCardCount(numDecks);
            
            if (totalCardsDisplay) {
                totalCardsDisplay.textContent = totalCards;
            }
            
            if (feedbackDiv) {
                const validation = validateDeckCount(numDecks);
                if (validation.valid) {
                    feedbackDiv.innerHTML = `<span class="text-gray-600 text-sm">${numDecks} deck${numDecks > 1 ? 's' : ''} = ${totalCards} cards</span>`;
                } else {
                    feedbackDiv.innerHTML = `<span class="text-red-600 text-sm">${validation.message}</span>`;
                }
            }
        }

        // Initialize setup phase when page loads
        function initializeSetupPhase() {
            const deckCountInput = document.getElementById('deck-count');
            
            if (deckCountInput) {
                // Add event listener for real-time updates
                deckCountInput.addEventListener('input', updateCardCountDisplay);
                deckCountInput.addEventListener('change', updateCardCountDisplay);
                
                // Initial update
                updateCardCountDisplay();
            }
            
            // Reset start button state
            const startBtn = document.getElementById('start-memorization-btn');
            if (startBtn) {
                startBtn.disabled = false;
                startBtn.textContent = 'Start Memorizing Cards';
            }
            
            // Hide any errors
            hideSetupError();
        }

        // Page initialization
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Memory Palace Cards initialized');
            initializeSetupPhase();
        });

        // Memorization phase interface functions
        
        function updateMemorizationInterface() {
            const currentCard = getCurrentCard();
            if (!currentCard) {
                console.error('No current card available for display');
                return false;
            }
            
            // Update card display
            updateMemorizationCardDisplay(currentCard);
            
            // Update progress information
            updateMemorizationProgress();
            
            // Update card information text
            updateCardInformation(currentCard);
            
            return true;
        }

        function updateMemorizationCardDisplay(card) {
            const cardDisplay = document.getElementById('memorization-card-display');
            if (!cardDisplay || !card) return false;
            
            // Update card content and styling
            updateCardContent(cardDisplay, card);
            
            // Add initial bounce animation for first display
            if (gameState.currentCardIndex === 0 && !cardDisplay.style.opacity) {
                return animateInitialCard(card);
            } else {
                // Simple fade for regular updates
                return fadeIn(cardDisplay, 300);
            }
        }

        function updateMemorizationProgress() {
            const currentCardNumber = gameState.currentCardIndex + 1;
            const totalCards = gameState.totalCards;
            const progressPercent = getMemorizationProgress();
            
            // Update card counter
            const currentCardNumElement = document.getElementById('current-card-number');
            if (currentCardNumElement) {
                currentCardNumElement.textContent = currentCardNumber;
            }
            
            const totalCardCountElement = document.getElementById('total-card-count');
            if (totalCardCountElement) {
                totalCardCountElement.textContent = totalCards;
            }
            
            // Update progress percentage
            const progressPercentElement = document.getElementById('memorization-progress-percent');
            if (progressPercentElement) {
                progressPercentElement.textContent = progressPercent;
            }
            
            // Update progress bar
            const progressFill = document.getElementById('memorization-progress-fill');
            if (progressFill) {
                progressFill.style.width = `${progressPercent}%`;
            }
            
            return true;
        }

        function updateCardInformation(card) {
            if (!card) return false;
            
            // Update suit display
            const suitElement = document.getElementById('current-card-suit');
            if (suitElement) {
                suitElement.textContent = card.suit;
                suitElement.className = `font-bold ${getCardColorClass(card)}`;
            }
            
            // Update rank display
            const rankElement = document.getElementById('current-card-rank');
            if (rankElement) {
                rankElement.textContent = card.rank;
                rankElement.className = `font-bold ${getCardColorClass(card)}`;
            }
            
            return true;
        }

        function showMemorizationCard(cardIndex) {
            if (cardIndex < 0 || cardIndex >= gameState.cards.length) {
                console.error(`Invalid card index: ${cardIndex}`);
                return false;
            }
            
            gameState.currentCardIndex = cardIndex;
            return updateMemorizationInterface();
        }

        function getCurrentMemorizationCard() {
            return gameState.cards[gameState.currentCardIndex] || null;
        }

        function isFirstCard() {
            return gameState.currentCardIndex === 0;
        }

        function isLastCard() {
            return gameState.currentCardIndex === gameState.cards.length - 1;
        }

        // Enhanced card display with multiple animation types
        function animateCardChange(newCard, direction = 'next') {
            const cardDisplay = document.getElementById('memorization-card-display');
            if (!cardDisplay || !newCard) return false;
            
            // Choose animation based on direction and user preference
            let animationPromise;
            
            switch(direction) {
                case 'next':
                    animationPromise = slideOut(cardDisplay, 'left', 200).then(() => {
                        updateCardContent(cardDisplay, newCard);
                        return slideIn(cardDisplay, 'right', 300);
                    });
                    break;
                case 'previous':
                    animationPromise = slideOut(cardDisplay, 'right', 200).then(() => {
                        updateCardContent(cardDisplay, newCard);
                        return slideIn(cardDisplay, 'left', 300);
                    });
                    break;
                case 'jump':
                    animationPromise = bounceIn(cardDisplay, 400).then(() => {
                        updateCardContent(cardDisplay, newCard);
                        return Promise.resolve();
                    });
                    break;
                case 'flip':
                    animationPromise = flipCard(cardDisplay, 500).then(() => {
                        updateCardContent(cardDisplay, newCard);
                        return Promise.resolve();
                    });
                    break;
                default:
                    animationPromise = fadeOut(cardDisplay, 200).then(() => {
                        updateCardContent(cardDisplay, newCard);
                        return fadeIn(cardDisplay, 250);
                    });
            }
            
            // Update other interface elements with slight delay for smooth feel
            setTimeout(() => {
                updateMemorizationProgress();
                updateCardInformation(newCard);
                animateProgressElements();
            }, 100);
            
            return animationPromise;
        }

        function updateCardContent(cardDisplay, newCard) {
            cardDisplay.textContent = newCard.getDisplayString();
            cardDisplay.className = `card-display ${newCard.getSuitClass()}`;
        }

        function animateProgressElements() {
            // Animate progress bar
            const progressFill = document.getElementById('memorization-progress-fill');
            if (progressFill) {
                progressFill.style.transition = 'width 0.5s ease-out';
            }
            
            // Animate progress numbers
            const progressElements = [
                'current-card-number',
                'memorization-progress-percent',
                'cards-seen',
                'cards-remaining'
            ];
            
            progressElements.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.style.transition = 'all 0.3s ease-out';
                    element.style.transform = 'scale(1.1)';
                    setTimeout(() => {
                        element.style.transform = 'scale(1)';
                    }, 200);
                }
            });
        }

        // Specialized animation for initial card display
        function animateInitialCard(card) {
            const cardDisplay = document.getElementById('memorization-card-display');
            if (!cardDisplay || !card) return false;
            
            updateCardContent(cardDisplay, card);
            return bounceIn(cardDisplay, 800);
        }

        // Animation for milestone celebrations
        function animateMilestoneCard() {
            const cardDisplay = document.getElementById('memorization-card-display');
            if (!cardDisplay) return;
            
            // Add a special glow effect
            cardDisplay.style.boxShadow = '0 0 30px rgba(102, 126, 234, 0.6)';
            cardDisplay.style.transition = 'box-shadow 0.5s ease-out';
            
            setTimeout(() => {
                cardDisplay.style.boxShadow = '0 4px 15px rgba(0,0,0,0.1)';
            }, 1500);
        }

        // Smooth phase transitions
        function animatePhaseTransition(fromPhase, toPhase) {
            const fromElement = document.getElementById(`${fromPhase}-phase`);
            const toElement = document.getElementById(`${toPhase}-phase`);
            
            if (!fromElement || !toElement) return Promise.resolve();
            
            return fadeOut(fromElement, 300).then(() => {
                fromElement.classList.remove('active');
                fromElement.classList.add('hidden');
                
                toElement.classList.remove('hidden');
                toElement.classList.add('active');
                
                return slideIn(toElement, 'up', 400);
            });
        }

        // Initialize memorization phase
        function initializeMemorizationPhase() {
            console.log('Initializing memorization phase');
            
            // Show first card
            if (gameState.cards.length > 0) {
                gameState.currentCardIndex = 0;
                updateMemorizationInterface();
            } else {
                console.error('No cards available for memorization');
                return false;
            }
            
            return true;
        }

        // Memory tips system
        const memoryTips = [
            "Create a mental image or story to remember this card's position and details.",
            "Associate this card with a familiar object or person.",
            "Try to remember the card's position in your mental palace.",
            "Link this card to the previous one with a memorable connection.",
            "Visualize the card in a specific location you know well.",
            "Create a rhyme or phrase that includes the card's suit and rank.",
            "Think about what makes this card unique or special.",
            "Connect this card to a memory or experience you've had."
        ];

        function updateMemoryTip() {
            const tipElement = document.querySelector('.bg-blue-50 .text-blue-700');
            if (tipElement && memoryTips.length > 0) {
                const randomTip = memoryTips[Math.floor(Math.random() * memoryTips.length)];
                tipElement.textContent = randomTip;
            }
        }

        // Navigation control handlers
        
        function handlePreviousCard() {
            if (canGoPrevious()) {
                const success = previousCard();
                if (success) {
                    const currentCard = getCurrentCard();
                    animateCardChange(currentCard, 'previous');
                    updateNavigationButtons();
                    updateMemoryTip();
                }
            }
        }

        function handleNextCard() {
            if (canGoNext()) {
                const success = nextCard();
                if (success) {
                    const currentCard = getCurrentCard();
                    animateCardChange(currentCard, 'next');
                    updateNavigationButtons();
                    updateMemoryTip();
                }
            }
        }

        function handleStartTesting() {
            // Confirm user wants to start testing
            const confirmed = confirm('Are you ready to test your memory? You can start testing at any time, even if you haven\'t seen all cards yet.');
            
            if (confirmed) {
                const success = startTesting();
                if (!success) {
                    alert('Failed to start testing. Please try again.');
                }
            }
        }

        function handleShuffleCards() {
            const confirmed = confirm('This will shuffle all the cards and reset your progress. Are you sure?');
            
            if (confirmed) {
                const success = shuffleCards();
                if (success) {
                    // Reset to first card
                    gameState.currentCardIndex = 0;
                    updateMemorizationInterface();
                    updateNavigationButtons();
                    updateJumpToCardMax();
                    updateMemoryTip();
                    
                    // Show feedback
                    showTemporaryMessage('Cards shuffled! Starting over from the first card.', 'info');
                }
            }
        }

        function handleJumpToCard() {
            const jumpInput = document.getElementById('jump-to-card');
            const cardNumber = parseInt(jumpInput.value);
            
            if (isNaN(cardNumber) || cardNumber < 1 || cardNumber > gameState.totalCards) {
                showTemporaryMessage(`Please enter a number between 1 and ${gameState.totalCards}`, 'error');
                return;
            }
            
            // Convert to zero-based index
            const cardIndex = cardNumber - 1;
            
            if (cardIndex !== gameState.currentCardIndex) {
                gameState.currentCardIndex = cardIndex;
                const currentCard = getCurrentCard();
                animateCardChange(currentCard, 'jump');
                updateNavigationButtons();
                updateMemoryTip();
                
                // Clear the input
                jumpInput.value = '';
            }
        }

        function updateNavigationButtons() {
            const prevBtn = document.getElementById('prev-card-btn');
            const nextBtn = document.getElementById('next-card-btn');
            
            if (prevBtn) {
                prevBtn.disabled = !canGoPrevious();
                if (prevBtn.disabled) {
                    prevBtn.className = 'flex-1 py-3 px-4 bg-gray-100 text-gray-400 border border-gray-300 cursor-not-allowed';
                } else {
                    prevBtn.className = 'flex-1 py-3 px-4 bg-gray-100 text-gray-700 border border-gray-300 hover:bg-gray-200';
                }
            }
            
            if (nextBtn) {
                nextBtn.disabled = !canGoNext();
                if (nextBtn.disabled) {
                    nextBtn.className = 'flex-1 py-3 px-4 bg-gray-100 text-gray-400 border border-gray-300 cursor-not-allowed';
                    nextBtn.textContent = 'Last Card';
                } else {
                    nextBtn.className = 'flex-1 py-3 px-4';
                    nextBtn.textContent = 'Next →';
                }
            }
        }

        function updateJumpToCardMax() {
            const jumpInput = document.getElementById('jump-to-card');
            if (jumpInput) {
                jumpInput.max = gameState.totalCards;
                jumpInput.placeholder = Math.min(gameState.currentCardIndex + 1, gameState.totalCards).toString();
            }
        }

        function showTemporaryMessage(message, type = 'info', duration = 3000) {
            // Create message element
            const messageDiv = document.createElement('div');
            messageDiv.className = `fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg max-w-sm ${
                type === 'error' ? 'bg-red-100 border border-red-400 text-red-700' :
                type === 'success' ? 'bg-green-100 border border-green-400 text-green-700' :
                'bg-blue-100 border border-blue-400 text-blue-700'
            }`;
            messageDiv.textContent = message;
            
            // Add to page
            document.body.appendChild(messageDiv);
            
            // Animate in
            messageDiv.style.opacity = '0';
            messageDiv.style.transform = 'translateX(100%)';
            messageDiv.style.transition = 'all 0.3s ease-out';
            
            setTimeout(() => {
                messageDiv.style.opacity = '1';
                messageDiv.style.transform = 'translateX(0)';
            }, 10);
            
            // Auto-remove
            setTimeout(() => {
                messageDiv.style.opacity = '0';
                messageDiv.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (messageDiv.parentNode) {
                        messageDiv.remove();
                    }
                }, 300);
            }, duration);
        }

        // Keyboard navigation support
        function handleKeyboardNavigation(event) {
            if (gameState.phase !== 'memorization') return;
            
            switch(event.key) {
                case 'ArrowLeft':
                    event.preventDefault();
                    handlePreviousCard();
                    break;
                case 'ArrowRight':
                    event.preventDefault();
                    handleNextCard();
                    break;
                case 'Enter':
                    if (event.target.id === 'jump-to-card') {
                        event.preventDefault();
                        handleJumpToCard();
                    } else if (event.ctrlKey || event.metaKey) {
                        event.preventDefault();
                        handleStartTesting();
                    }
                    break;
                case 'Escape':
                    // Could be used to go back to setup
                    break;
            }
        }

        // Initialize navigation
        function initializeMemorizationNavigation() {
            updateNavigationButtons();
            updateJumpToCardMax();
            
            // Add keyboard event listener
            document.addEventListener('keydown', handleKeyboardNavigation);
            
            // Add enter key support for jump input
            const jumpInput = document.getElementById('jump-to-card');
            if (jumpInput) {
                jumpInput.addEventListener('keypress', function(event) {
                    if (event.key === 'Enter') {
                        handleJumpToCard();
                    }
                });
            }
        }

        // Update the memorization interface initialization
        function initializeMemorizationPhase() {
            console.log('Initializing memorization phase');
            
            // Show first card
            if (gameState.cards.length > 0) {
                gameState.currentCardIndex = 0;
                updateMemorizationInterface();
                initializeMemorizationNavigation();
                updateMemoryTip();
            } else {
                console.error('No cards available for memorization');
                return false;
            }
            
            return true;
        }

        // Enhanced progress tracking
        let memorizationStartTime = null;
        let memorizationTimer = null;

        function updateMemorizationProgress() {
            const currentCardNumber = gameState.currentCardIndex + 1;
            const totalCards = gameState.totalCards;
            const progressPercent = getMemorizationProgress();
            
            // Update card counter
            const currentCardNumElement = document.getElementById('current-card-number');
            if (currentCardNumElement) {
                currentCardNumElement.textContent = currentCardNumber;
            }
            
            const totalCardCountElement = document.getElementById('total-card-count');
            if (totalCardCountElement) {
                totalCardCountElement.textContent = totalCards;
            }
            
            // Update progress percentage
            const progressPercentElement = document.getElementById('memorization-progress-percent');
            if (progressPercentElement) {
                progressPercentElement.textContent = progressPercent;
            }
            
            // Update progress bar with smooth animation
            const progressFill = document.getElementById('memorization-progress-fill');
            if (progressFill) {
                progressFill.style.width = `${progressPercent}%`;
            }
            
            // Update detailed progress stats
            updateDetailedProgressStats();
            
            return true;
        }

        function updateDetailedProgressStats() {
            const cardsSeen = gameState.currentCardIndex + 1;
            const cardsRemaining = gameState.totalCards - cardsSeen;
            
            // Update cards seen
            const cardsSeenElement = document.getElementById('cards-seen');
            if (cardsSeenElement) {
                cardsSeenElement.textContent = cardsSeen;
            }
            
            // Update cards remaining
            const cardsRemainingElement = document.getElementById('cards-remaining');
            if (cardsRemainingElement) {
                cardsRemainingElement.textContent = cardsRemaining;
            }
            
            // Update time spent
            updateTimeSpent();
        }

        function updateTimeSpent() {
            if (!memorizationStartTime) return;
            
            const timeSpentElement = document.getElementById('time-spent');
            if (!timeSpentElement) return;
            
            const currentTime = Date.now();
            const elapsedSeconds = Math.floor((currentTime - memorizationStartTime) / 1000);
            
            const minutes = Math.floor(elapsedSeconds / 60);
            const seconds = elapsedSeconds % 60;
            
            timeSpentElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function startMemorizationTimer() {
            if (memorizationStartTime) return; // Already started
            
            memorizationStartTime = Date.now();
            
            // Update timer every second
            memorizationTimer = setInterval(updateTimeSpent, 1000);
        }

        function stopMemorizationTimer() {
            if (memorizationTimer) {
                clearInterval(memorizationTimer);
                memorizationTimer = null;
            }
        }

        function resetMemorizationTimer() {
            stopMemorizationTimer();
            memorizationStartTime = null;
            
            const timeSpentElement = document.getElementById('time-spent');
            if (timeSpentElement) {
                timeSpentElement.textContent = '0:00';
            }
        }

        // Progress milestone celebrations
        function checkProgressMilestones() {
            const progressPercent = getMemorizationProgress();
            const milestones = [25, 50, 75, 100];
            
            // Check if we just hit a milestone
            milestones.forEach(milestone => {
                if (progressPercent >= milestone && !gameState.milestonesReached) {
                    gameState.milestonesReached = {};
                }
                
                if (progressPercent >= milestone && !gameState.milestonesReached[milestone]) {
                    gameState.milestonesReached[milestone] = true;
                    showProgressMilestone(milestone);
                }
            });
        }

        function showProgressMilestone(milestone) {
            const messages = {
                25: "🎉 Great start! You've seen 25% of the cards!",
                50: "💪 Halfway there! 50% of cards memorized!",
                75: "🔥 Excellent progress! 75% complete!",
                100: "🏆 Amazing! You've seen all the cards!"
            };
            
            const message = messages[milestone] || `${milestone}% complete!`;
            showTemporaryMessage(message, 'success', 4000);
            
            // Add special card animation for milestone
            animateMilestoneCard();
        }

        // Enhanced progress bar animations
        function animateProgressBar(targetPercent) {
            const progressFill = document.getElementById('memorization-progress-fill');
            if (!progressFill) return;
            
            const currentPercent = parseInt(progressFill.style.width) || 0;
            const increment = targetPercent > currentPercent ? 1 : -1;
            
            function updateProgress() {
                const current = parseInt(progressFill.style.width) || 0;
                
                if ((increment > 0 && current < targetPercent) || 
                    (increment < 0 && current > targetPercent)) {
                    progressFill.style.width = `${current + increment}%`;
                    requestAnimationFrame(updateProgress);
                }
            }
            
            requestAnimationFrame(updateProgress);
        }

        // Initialize progress tracking
        function initializeProgressTracking() {
            // Initialize milestone tracking
            gameState.milestonesReached = {};
            
            // Reset and start timer
            resetMemorizationTimer();
            startMemorizationTimer();
            
            // Initial progress update
            updateMemorizationProgress();
        }

        // Update the memorization phase initialization
        function initializeMemorizationPhase() {
            console.log('Initializing memorization phase');
            
            // Show first card
            if (gameState.cards.length > 0) {
                gameState.currentCardIndex = 0;
                updateMemorizationInterface();
                initializeMemorizationNavigation();
                initializeProgressTracking();
                updateMemoryTip();
            } else {
                console.error('No cards available for memorization');
                return false;
            }
            
            return true;
        }

        // Update navigation handlers to include progress tracking
        function handleNextCard() {
            if (canGoNext()) {
                const success = nextCard();
                if (success) {
                    const currentCard = getCurrentCard();
                    animateCardChange(currentCard, 'next');
                    updateNavigationButtons();
                    updateMemoryTip();
                    checkProgressMilestones();
                }
            }
        }

        function handlePreviousCard() {
            if (canGoPrevious()) {
                const success = previousCard();
                if (success) {
                    const currentCard = getCurrentCard();
                    animateCardChange(currentCard, 'previous');
                    updateNavigationButtons();
                    updateMemoryTip();
                }
            }
        }

        function handleJumpToCard() {
            const jumpInput = document.getElementById('jump-to-card');
            const cardNumber = parseInt(jumpInput.value);
            
            if (isNaN(cardNumber) || cardNumber < 1 || cardNumber > gameState.totalCards) {
                showTemporaryMessage(`Please enter a number between 1 and ${gameState.totalCards}`, 'error');
                return;
            }
            
            // Convert to zero-based index
            const cardIndex = cardNumber - 1;
            
            if (cardIndex !== gameState.currentCardIndex) {
                gameState.currentCardIndex = cardIndex;
                const currentCard = getCurrentCard();
                animateCardChange(currentCard, 'jump');
                updateNavigationButtons();
                updateMemoryTip();
                checkProgressMilestones();
                
                // Clear the input
                jumpInput.value = '';
            }
        }

        // Testing phase interface functions
        
        function updateTestingInterface() {
            if (gameState.phase !== 'testing') return false;
            
            // Stop memorization timer
            stopMemorizationTimer();
            
            // Initialize testing interface
            initializeTestingPhase();
            
            // Update current question
            updateTestingQuestion();
            
            // Update progress
            updateTestingProgress();
            
            return true;
        }

        function initializeTestingPhase() {
            console.log('Initializing testing phase');
            
            // Populate dropdowns
            const suitSelect = document.getElementById('suit-select');
            const rankSelect = document.getElementById('rank-select');
            
            if (suitSelect) {
                populateSuitDropdown(suitSelect);
            }
            
            if (rankSelect) {
                populateRankDropdown(rankSelect);
            }
            
            // Reset interface state
            resetTestingInterface();
            
            return true;
        }

        function resetTestingInterface() {
            // Reset dropdowns
            const suitSelect = document.getElementById('suit-select');
            const rankSelect = document.getElementById('rank-select');
            const submitBtn = document.getElementById('submit-answer-btn');
            
            if (suitSelect) {
                suitSelect.value = '';
            }
            
            if (rankSelect) {
                rankSelect.value = '';
                rankSelect.disabled = true;
                rankSelect.className = 'w-full text-center text-lg py-3 px-4 bg-gray-100 text-gray-400 cursor-not-allowed';
            }
            
            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.className = 'w-full py-3 px-6 text-lg font-semibold bg-gray-400 text-white border-none cursor-not-allowed';
            }
            
            // Clear feedback
            clearTestingFeedback();
        }

        function updateTestingQuestion() {
            const currentPosition = gameState.testingIndex + 1;
            const positionElement = document.getElementById('current-position');
            
            if (positionElement) {
                positionElement.textContent = currentPosition;
            }
        }

        function updateTestingProgress() {
            const currentCardNumber = gameState.testingIndex + 1;
            const totalCards = gameState.totalCards;
            const progressPercent = getTestingProgress();
            
            // Update card counter
            const testingCardNumElement = document.getElementById('testing-card-number');
            if (testingCardNumElement) {
                testingCardNumElement.textContent = currentCardNumber;
            }
            
            const testingTotalCardsElement = document.getElementById('testing-total-cards');
            if (testingTotalCardsElement) {
                testingTotalCardsElement.textContent = totalCards;
            }
            
            // Update progress percentage
            const progressPercentElement = document.getElementById('testing-progress-percent');
            if (progressPercentElement) {
                progressPercentElement.textContent = progressPercent;
            }
            
            // Update progress bar
            const progressFill = document.getElementById('testing-progress-fill');
            if (progressFill) {
                progressFill.style.width = `${progressPercent}%`;
                progressFill.style.transition = 'width 0.5s ease-out';
            }
        }

        // Event handlers for testing interface
        function handleSuitSelection() {
            const suitSelect = document.getElementById('suit-select');
            const rankSelect = document.getElementById('rank-select');
            
            if (!suitSelect || !rankSelect) return;
            
            const selectedSuit = suitSelect.value;
            
            if (selectedSuit) {
                // Enable rank selection
                rankSelect.disabled = false;
                rankSelect.className = 'w-full text-center text-lg py-3 px-4';
                
                // Focus on rank selection
                rankSelect.focus();
                
                // Add visual feedback
                suitSelect.style.borderColor = '#38a169';
                suitSelect.style.backgroundColor = '#f0fff4';
            } else {
                // Disable rank selection and submit button
                rankSelect.disabled = true;
                rankSelect.value = '';
                rankSelect.className = 'w-full text-center text-lg py-3 px-4 bg-gray-100 text-gray-400 cursor-not-allowed';
                
                updateSubmitButtonState();
                
                // Reset visual feedback
                suitSelect.style.borderColor = '#e2e8f0';
                suitSelect.style.backgroundColor = 'white';
            }
        }

        function handleRankSelection() {
            const rankSelect = document.getElementById('rank-select');
            
            if (!rankSelect) return;
            
            const selectedRank = rankSelect.value;
            
            if (selectedRank) {
                // Add visual feedback
                rankSelect.style.borderColor = '#38a169';
                rankSelect.style.backgroundColor = '#f0fff4';
            } else {
                // Reset visual feedback
                rankSelect.style.borderColor = '#e2e8f0';
                rankSelect.style.backgroundColor = 'white';
            }
            
            // Update submit button state
            updateSubmitButtonState();
        }

        function updateSubmitButtonState() {
            const suitSelect = document.getElementById('suit-select');
            const rankSelect = document.getElementById('rank-select');
            const submitBtn = document.getElementById('submit-answer-btn');
            
            if (!suitSelect || !rankSelect || !submitBtn) return;
            
            const canSubmit = suitSelect.value && rankSelect.value;
            
            submitBtn.disabled = !canSubmit;
            
            if (canSubmit) {
                submitBtn.className = 'w-full py-3 px-6 text-lg font-semibold bg-green-600 hover:bg-green-700 text-white border-none';
            } else {
                submitBtn.className = 'w-full py-3 px-6 text-lg font-semibold bg-gray-400 text-white border-none cursor-not-allowed';
            }
        }

        function clearTestingFeedback() {
            const feedbackContainer = document.getElementById('testing-feedback');
            if (feedbackContainer) {
                feedbackContainer.innerHTML = '';
            }
        }

        function showTestingFeedback(isCorrect, message, duration = 3000) {
            const feedbackContainer = document.getElementById('testing-feedback');
            if (!feedbackContainer) return;
            
            // Clear existing feedback
            feedbackContainer.innerHTML = '';
            
            // Create feedback element
            const feedback = createFeedbackElement(isCorrect, message);
            feedbackContainer.appendChild(feedback);
            
            // Add fade-in animation
            fadeIn(feedback, 300);
            
            // Auto-remove after duration
            if (duration > 0) {
                setTimeout(() => {
                    fadeOut(feedback, 300).then(() => {
                        if (feedback.parentNode) {
                            feedback.remove();
                        }
                    });
                }, duration);
            }
        }

        // Enhanced suit dropdown population with symbols
        function populateSuitDropdown(selectElement) {
            if (!selectElement) return false;
            
            // Clear existing options
            selectElement.innerHTML = '<option value="">Select Suit</option>';
            
            SUITS.forEach(suit => {
                const option = document.createElement('option');
                option.value = suit;
                option.textContent = `${suit} ${SUIT_SYMBOLS[suit]}`;
                
                // Add color styling for visual appeal
                if (suit === 'Hearts' || suit === 'Diamonds') {
                    option.style.color = '#e53e3e';
                } else {
                    option.style.color = '#2d3748';
                }
                
                selectElement.appendChild(option);
            });
            
            return true;
        }

        // Enhanced rank dropdown population with descriptions
        function populateRankDropdown(selectElement) {
            if (!selectElement) return false;
            
            // Clear existing options
            selectElement.innerHTML = '<option value="">Select Rank</option>';
            
            // Rank descriptions for better UX
            const rankDescriptions = {
                'A': 'A (Ace)',
                '2': '2 (Two)',
                '3': '3 (Three)',
                '4': '4 (Four)',
                '5': '5 (Five)',
                '6': '6 (Six)',
                '7': '7 (Seven)',
                '8': '8 (Eight)',
                '9': '9 (Nine)',
                '10': '10 (Ten)',
                'J': 'J (Jack)',
                'Q': 'Q (Queen)',
                'K': 'K (King)'
            };
            
            RANKS.forEach(rank => {
                const option = document.createElement('option');
                option.value = rank;
                option.textContent = rankDescriptions[rank] || rank;
                
                // Add special styling for face cards and ace
                if (rank === 'A' || rank === 'J' || rank === 'Q' || rank === 'K') {
                    option.style.fontWeight = 'bold';
                    option.style.color = '#4c51bf';
                } else {
                    option.style.color = '#2d3748';
                }
                
                selectElement.appendChild(option);
            });
            
            return true;
        }

        // Keyboard navigation for dropdowns
        function addDropdownKeyboardSupport() {
            const suitSelect = document.getElementById('suit-select');
            const rankSelect = document.getElementById('rank-select');
            
            if (suitSelect) {
                suitSelect.addEventListener('keydown', function(event) {
                    if (event.key === 'Enter' && this.value) {
                        handleSuitSelection();
                        // Move focus to rank dropdown if suit is selected
                        const rankSelect = document.getElementById('rank-select');
                        if (rankSelect && !rankSelect.disabled) {
                            rankSelect.focus();
                        }
                    }
                });
            }
            
            if (rankSelect) {
                rankSelect.addEventListener('keydown', function(event) {
                    if (event.key === 'Enter' && this.value) {
                        handleRankSelection();
                        // Move focus to submit button if both selections are made
                        const submitBtn = document.getElementById('submit-answer-btn');
                        if (submitBtn && !submitBtn.disabled) {
                            submitBtn.focus();
                        }
                    }
                });
            }
        }

        // Enhanced dropdown validation
        function validateDropdownSelections() {
            const suitSelect = document.getElementById('suit-select');
            const rankSelect = document.getElementById('rank-select');
            
            if (!suitSelect || !rankSelect) return { valid: false, errors: ['Dropdown elements not found'] };
            
            const errors = [];
            
            if (!suitSelect.value) {
                errors.push('Please select a suit');
            } else if (!SUITS.includes(suitSelect.value)) {
                errors.push('Invalid suit selection');
            }
            
            if (!rankSelect.value) {
                errors.push('Please select a rank');
            } else if (!RANKS.includes(rankSelect.value)) {
                errors.push('Invalid rank selection');
            }
            
            return {
                valid: errors.length === 0,
                errors: errors,
                suit: suitSelect.value,
                rank: rankSelect.value
            };
        }

        // Visual feedback for selections
        function updateDropdownVisualFeedback(elementId, isValid, isSelected) {
            const element = document.getElementById(elementId);
            if (!element) return;
            
            // Reset classes
            element.style.borderColor = '';
            element.style.backgroundColor = '';
            element.style.boxShadow = '';
            
            if (isSelected && isValid) {
                // Valid selection - green
                element.style.borderColor = '#38a169';
                element.style.backgroundColor = '#f0fff4';
                element.style.boxShadow = '0 0 0 3px rgba(56, 161, 105, 0.1)';
            } else if (isSelected && !isValid) {
                // Invalid selection - red
                element.style.borderColor = '#e53e3e';
                element.style.backgroundColor = '#fef5f5';
                element.style.boxShadow = '0 0 0 3px rgba(229, 62, 62, 0.1)';
            } else {
                // Default state
                element.style.borderColor = '#e2e8f0';
                element.style.backgroundColor = 'white';
            }
        }

        // Enhanced suit selection handler
        function handleSuitSelection() {
            const suitSelect = document.getElementById('suit-select');
            const rankSelect = document.getElementById('rank-select');
            
            if (!suitSelect || !rankSelect) return;
            
            const selectedSuit = suitSelect.value;
            const isValidSuit = SUITS.includes(selectedSuit);
            
            // Update visual feedback
            updateDropdownVisualFeedback('suit-select', isValidSuit, !!selectedSuit);
            
            if (selectedSuit && isValidSuit) {
                // Enable rank selection
                rankSelect.disabled = false;
                rankSelect.className = 'w-full text-center text-lg py-3 px-4';
                
                // Focus on rank selection for better UX
                setTimeout(() => rankSelect.focus(), 100);
                
                // Add smooth transition effect
                rankSelect.style.transition = 'all 0.3s ease-out';
                rankSelect.style.opacity = '1';
            } else {
                // Disable rank selection and reset
                rankSelect.disabled = true;
                rankSelect.value = '';
                rankSelect.className = 'w-full text-center text-lg py-3 px-4 bg-gray-100 text-gray-400 cursor-not-allowed';
                rankSelect.style.opacity = '0.6';
                
                // Reset rank visual feedback
                updateDropdownVisualFeedback('rank-select', false, false);
            }
            
            // Update submit button state
            updateSubmitButtonState();
        }

        // Enhanced rank selection handler
        function handleRankSelection() {
            const rankSelect = document.getElementById('rank-select');
            
            if (!rankSelect) return;
            
            const selectedRank = rankSelect.value;
            const isValidRank = RANKS.includes(selectedRank);
            
            // Update visual feedback
            updateDropdownVisualFeedback('rank-select', isValidRank, !!selectedRank);
            
            // Update submit button state
            updateSubmitButtonState();
            
            // Auto-focus submit button if both selections are valid
            if (selectedRank && isValidRank) {
                const validation = validateDropdownSelections();
                if (validation.valid) {
                    const submitBtn = document.getElementById('submit-answer-btn');
                    if (submitBtn && !submitBtn.disabled) {
                        setTimeout(() => submitBtn.focus(), 100);
                    }
                }
            }
        }

        // Initialize testing interface with enhanced features
        function initializeTestingPhase() {
            console.log('Initializing testing phase');
            
            // Populate dropdowns
            const suitSelect = document.getElementById('suit-select');
            const rankSelect = document.getElementById('rank-select');
            
            if (suitSelect) {
                populateSuitDropdown(suitSelect);
            }
            
            if (rankSelect) {
                populateRankDropdown(rankSelect);
            }
            
            // Add keyboard support
            addDropdownKeyboardSupport();
            
            // Reset interface state
            resetTestingInterface();
            
            return true;
        }

        // Button handlers for testing phase
        
        function handleSubmitAnswer() {
            const validation = validateDropdownSelections();
            
            if (!validation.valid) {
                showTestingFeedback(false, validation.errors.join(', '), 3000);
                return;
            }
            
            // Submit the answer
            const result = submitAnswer(validation.suit, validation.rank);
            
            if (result) {
                // Show enhanced detailed feedback
                showDetailedFeedback(result.isCorrect, result.correctCard, validation.suit, validation.rank);
                
                // Disable inputs temporarily
                disableTestingInputs();
                
                // Move to next card after delay
                setTimeout(() => {
                    moveToNextTestCard();
                }, 2500);
            } else {
                showTestingFeedback(false, 'Error submitting answer. Please try again.', 3000);
            }
        }

        function handleSkipCard() {
            const confirmed = confirm('Are you sure you want to skip this card? You won\'t get another chance to answer it.');
            
            if (confirmed) {
                // Skip the current card
                const success = skipAnswer();
                
                if (success) {
                    showProgressFeedback('Card skipped', 'warning');
                    
                    // Move to next card after short delay
                    setTimeout(() => {
                        moveToNextTestCard();
                    }, 1500);
                } else {
                    showTestingFeedback(false, 'Error skipping card. Please try again.', 3000);
                }
            }
        }

        function handleFinishTesting() {
            const remainingCards = gameState.totalCards - gameState.testingIndex - 1;
            let confirmMessage;
            
            if (remainingCards > 0) {
                confirmMessage = `Are you sure you want to finish testing? You still have ${remainingCards} card${remainingCards > 1 ? 's' : ''} remaining. These will be marked as skipped.`;
            } else {
                confirmMessage = 'Finish testing and see your results?';
            }
            
            const confirmed = confirm(confirmMessage);
            
            if (confirmed) {
                // Mark remaining cards as skipped
                if (remainingCards > 0) {
                    for (let i = gameState.testingIndex; i < gameState.totalCards; i++) {
                        if (!gameState.userAnswers[i] || (!gameState.userAnswers[i].suit && !gameState.userAnswers[i].isSkipped)) {
                            gameState.userAnswers[i] = {
                                suit: null,
                                rank: null,
                                isCorrect: false,
                                isSkipped: true
                            };
                        }
                    }
                }
                
                // Finish testing
                finishTesting();
                
                // Update results interface will be implemented in next task
                updateResultsInterface();
            }
        }

        function moveToNextTestCard() {
            const hasNext = nextTestCard();
            
            if (hasNext) {
                // Reset interface for next card
                resetTestingInterface();
                updateTestingQuestion();
                updateTestingProgress();
                updateTestingStatistics();
                
                // Check for milestone celebrations
                const cardNumber = gameState.testingIndex + 1;
                showProgressMilestone(cardNumber, gameState.totalCards);
                
                // Add smooth transition
                const questionArea = document.querySelector('.bg-gray-50.border-2');
                if (questionArea) {
                    slideIn(questionArea, 'up', 300);
                }
            }
            // If no more cards, finishTesting() is called automatically by nextTestCard()
        }

        function disableTestingInputs() {
            const suitSelect = document.getElementById('suit-select');
            const rankSelect = document.getElementById('rank-select');
            const submitBtn = document.getElementById('submit-answer-btn');
            
            if (suitSelect) {
                suitSelect.disabled = true;
                suitSelect.style.opacity = '0.6';
            }
            
            if (rankSelect) {
                rankSelect.disabled = true;
                rankSelect.style.opacity = '0.6';
            }
            
            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.className = 'w-full py-3 px-6 text-lg font-semibold bg-gray-400 text-white border-none cursor-not-allowed';
            }
        }

        function enableTestingInputs() {
            const suitSelect = document.getElementById('suit-select');
            const rankSelect = document.getElementById('rank-select');
            
            if (suitSelect) {
                suitSelect.disabled = false;
                suitSelect.style.opacity = '1';
            }
            
            // Rank select will be enabled by suit selection handler
            if (rankSelect) {
                rankSelect.style.opacity = '1';
            }
        }

        // Enhanced reset function
        function resetTestingInterface() {
            // Reset dropdowns
            const suitSelect = document.getElementById('suit-select');
            const rankSelect = document.getElementById('rank-select');
            const submitBtn = document.getElementById('submit-answer-btn');
            
            if (suitSelect) {
                suitSelect.value = '';
                suitSelect.disabled = false;
                updateDropdownVisualFeedback('suit-select', false, false);
            }
            
            if (rankSelect) {
                rankSelect.value = '';
                rankSelect.disabled = true;
                rankSelect.className = 'w-full text-center text-lg py-3 px-4 bg-gray-100 text-gray-400 cursor-not-allowed';
                updateDropdownVisualFeedback('rank-select', false, false);
            }
            
            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.className = 'w-full py-3 px-6 text-lg font-semibold bg-gray-400 text-white border-none cursor-not-allowed';
            }
            
            // Enable inputs
            enableTestingInputs();
            
            // Clear feedback
            clearTestingFeedback();
            
            // Focus on suit select for better UX
            setTimeout(() => {
                if (suitSelect && !suitSelect.disabled) {
                    suitSelect.focus();
                }
            }, 100);
        }

        // Button state management
        function updateButtonStates() {
            const suitSelect = document.getElementById('suit-select');
            const rankSelect = document.getElementById('rank-select');
            const submitBtn = document.getElementById('submit-answer-btn');
            const skipBtn = document.getElementById('skip-card-btn');
            const finishBtn = document.getElementById('finish-testing-btn');
            
            const validation = validateDropdownSelections();
            
            // Update submit button
            if (submitBtn) {
                submitBtn.disabled = !validation.valid;
                if (validation.valid) {
                    submitBtn.className = 'w-full py-3 px-6 text-lg font-semibold bg-green-600 hover:bg-green-700 text-white border-none';
                } else {
                    submitBtn.className = 'w-full py-3 px-6 text-lg font-semibold bg-gray-400 text-white border-none cursor-not-allowed';
                }
            }
            
            // Skip and finish buttons are always enabled during testing
            if (skipBtn) {
                skipBtn.disabled = false;
            }
            
            if (finishBtn) {
                finishBtn.disabled = false;
            }
        }

        // Enhanced submit button state function
        function updateSubmitButtonState() {
            updateButtonStates();
        }

        // Keyboard shortcuts for testing phase
        function addTestingKeyboardShortcuts() {
            document.addEventListener('keydown', function(event) {
                if (gameState.phase !== 'testing') return;
                
                // Only handle shortcuts if no input is focused
                if (document.activeElement.tagName === 'SELECT') return;
                
                switch(event.key) {
                    case 'Enter':
                        event.preventDefault();
                        const submitBtn = document.getElementById('submit-answer-btn');
                        if (submitBtn && !submitBtn.disabled) {
                            handleSubmitAnswer();
                        }
                        break;
                    case 's':
                    case 'S':
                        event.preventDefault();
                        handleSkipCard();
                        break;
                    case 'f':
                    case 'F':
                        if (event.ctrlKey || event.metaKey) {
                            event.preventDefault();
                            handleFinishTesting();
                        }
                        break;
                    case 'Escape':
                        event.preventDefault();
                        handleFinishTesting();
                        break;
                }
            });
        }

        // Initialize testing phase with all enhancements
        function initializeTestingPhase() {
            console.log('Initializing testing phase');
            
            // Populate dropdowns
            const suitSelect = document.getElementById('suit-select');
            const rankSelect = document.getElementById('rank-select');
            
            if (suitSelect) {
                populateSuitDropdown(suitSelect);
            }
            
            if (rankSelect) {
                populateRankDropdown(rankSelect);
            }
            
            // Add keyboard support
            addDropdownKeyboardSupport();
            addTestingKeyboardShortcuts();
            
            // Reset interface state
            resetTestingInterface();
            
            return true;
        }

        // Core game logic functions for testing phase
        
        function submitAnswer(suit, rank) {
            try {
                const currentCard = gameState.cards[gameState.testingIndex];
                if (!currentCard) {
                    console.error('No current card found');
                    return null;
                }
                
                const isCorrect = currentCard.equals(suit, rank);
                
                // Store user answer
                gameState.userAnswers[gameState.testingIndex] = {
                    suit: suit,
                    rank: rank,
                    isCorrect: isCorrect,
                    isSkipped: false
                };
                
                console.log(`Answer submitted: ${rank}${SUIT_SYMBOLS[suit]}, Correct: ${isCorrect}`);
                
                return {
                    correctCard: currentCard,
                    isCorrect: isCorrect
                };
            } catch (error) {
                console.error('Error submitting answer:', error);
                return null;
            }
        }

        function skipAnswer() {
            try {
                // Store skipped answer
                gameState.userAnswers[gameState.testingIndex] = {
                    suit: null,
                    rank: null,
                    isCorrect: false,
                    isSkipped: true
                };
                
                console.log('Card skipped');
                return true;
            } catch (error) {
                console.error('Error skipping answer:', error);
                return false;
            }
        }

        function nextTestCard() {
            gameState.testingIndex++;
            
            if (gameState.testingIndex >= gameState.totalCards) {
                // Testing complete
                console.log('Testing phase complete');
                finishTesting();
                return false;
            }
            
            return true;
        }

        function finishTesting() {
            console.log('Finishing testing phase');
            
            // Calculate final statistics
            gameState.calculateStats();
            
            // Switch to results phase
            gameState.phase = 'results';
            setPhase('results');
            
            // Update results display will be implemented in next task
            console.log('Statistics:', gameState.stats);
        }

        // Enhanced Testing feedback functions
        
        function showTestingFeedback(isCorrect, message, duration = 3000) {
            const feedbackArea = document.getElementById('testing-feedback');
            if (!feedbackArea) return;
            
            // Clear existing feedback
            clearTestingFeedback();
            
            // Create feedback container
            const feedback = document.createElement('div');
            feedback.className = `feedback-message p-4 rounded-xl text-center font-bold text-lg shadow-lg border-2 ${
                isCorrect ? 'bg-gradient-to-r from-green-50 to-green-100 text-green-800 border-green-400' : 
                           'bg-gradient-to-r from-red-50 to-red-100 text-red-800 border-red-400'
            }`;
            
            // Add icon and message
            const icon = isCorrect ? '✅' : '❌';
            const iconSpan = document.createElement('span');
            iconSpan.className = 'text-2xl mr-2';
            iconSpan.textContent = icon;
            
            const messageSpan = document.createElement('span');
            messageSpan.textContent = message;
            
            feedback.appendChild(iconSpan);
            feedback.appendChild(messageSpan);
            
            // Add celebration animation for correct answers
            if (isCorrect) {
                feedback.style.animation = 'bounce 0.6s ease-in-out';
                
                // Add confetti effect for correct answers
                createConfettiEffect(feedback);
            } else {
                feedback.style.animation = 'shake 0.5s ease-in-out';
            }
            
            feedbackArea.appendChild(feedback);
            
            // Add entrance animation
            slideIn(feedback, 'up', 400);
            
            // Auto-clear after duration
            if (duration > 0) {
                setTimeout(() => {
                    fadeOut(feedback, 300, () => {
                        clearTestingFeedback();
                    });
                }, duration);
            }
        }

        function showProgressFeedback(message, type = 'info') {
            const feedbackArea = document.getElementById('testing-feedback');
            if (!feedbackArea) return;
            
            const feedback = document.createElement('div');
            let className = 'p-3 rounded-lg text-center font-semibold border-2 ';
            
            switch(type) {
                case 'success':
                    className += 'bg-green-50 text-green-700 border-green-300';
                    break;
                case 'warning':
                    className += 'bg-yellow-50 text-yellow-700 border-yellow-300';
                    break;
                case 'error':
                    className += 'bg-red-50 text-red-700 border-red-300';
                    break;
                default:
                    className += 'bg-blue-50 text-blue-700 border-blue-300';
            }
            
            feedback.className = className;
            feedback.textContent = message;
            
            feedbackArea.appendChild(feedback);
            fadeIn(feedback, 200);
            
            // Auto-clear after short duration
            setTimeout(() => {
                fadeOut(feedback, 200, () => {
                    if (feedback.parentNode) {
                        feedback.parentNode.removeChild(feedback);
                    }
                });
            }, 1500);
        }

        function createConfettiEffect(element) {
            // Create simple confetti particles
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3'];
            
            for (let i = 0; i < 12; i++) {
                const confetti = document.createElement('div');
                confetti.style.position = 'absolute';
                confetti.style.width = '8px';
                confetti.style.height = '8px';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.borderRadius = '50%';
                confetti.style.pointerEvents = 'none';
                confetti.style.zIndex = '1000';
                
                // Position around the element
                const rect = element.getBoundingClientRect();
                confetti.style.left = (rect.left + Math.random() * rect.width) + 'px';
                confetti.style.top = (rect.top + Math.random() * rect.height) + 'px';
                
                document.body.appendChild(confetti);
                
                // Animate confetti
                const animation = confetti.animate([
                    { 
                        transform: 'translateY(0px) rotate(0deg) scale(1)',
                        opacity: 1
                    },
                    { 
                        transform: `translateY(-${50 + Math.random() * 100}px) rotate(${Math.random() * 360}deg) scale(0)`,
                        opacity: 0
                    }
                ], {
                    duration: 1000 + Math.random() * 500,
                    easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
                });
                
                animation.onfinish = () => {
                    if (confetti.parentNode) {
                        confetti.parentNode.removeChild(confetti);
                    }
                };
            }
        }

        function clearTestingFeedback() {
            const feedbackArea = document.getElementById('testing-feedback');
            if (feedbackArea) {
                feedbackArea.innerHTML = '';
            }
        }

        // Enhanced feedback with detailed statistics
        function showDetailedFeedback(isCorrect, correctCard, userSuit, userRank) {
            const currentIndex = gameState.testingIndex;
            const totalCards = gameState.totalCards;
            const cardPosition = currentIndex + 1;
            
            let message;
            if (isCorrect) {
                message = `Perfect! Card #${cardPosition} was indeed ${correctCard.getDisplayString()}`;
            } else {
                const userAnswer = userSuit && userRank ? `${userRank}${SUIT_SYMBOLS[userSuit]}` : 'No answer';
                message = `Card #${cardPosition} was ${correctCard.getDisplayString()}, you answered ${userAnswer}`;
            }
            
            showTestingFeedback(isCorrect, message, 2500);
            
            // Show progress update
            setTimeout(() => {
                const remaining = totalCards - cardPosition;
                if (remaining > 0) {
                    showProgressFeedback(`${remaining} cards remaining`, 'info');
                }
            }, 2800);
        }

        // Enhanced Testing progress and question updates
        
        function updateTestingQuestion() {
            const questionElement = document.getElementById('testing-question');
            if (questionElement) {
                const cardNumber = gameState.testingIndex + 1;
                const totalCards = gameState.totalCards;
                questionElement.textContent = `What was card #${cardNumber}?`;
            }
        }

        function updateTestingProgress() {
            const cardNumber = gameState.testingIndex + 1;
            const totalCards = gameState.totalCards;
            const percentage = Math.round((cardNumber / totalCards) * 100);
            
            // Update progress text
            const progressElement = document.getElementById('testing-progress');
            if (progressElement) {
                progressElement.textContent = `Card ${cardNumber} of ${totalCards} (${percentage}% complete)`;
            }
            
            // Update progress percentage display
            const progressPercentElement = document.getElementById('testing-progress-percent');
            if (progressPercentElement) {
                progressPercentElement.textContent = percentage;
            }
            
            // Update progress bar
            const progressFill = document.getElementById('testing-progress-fill');
            if (progressFill) {
                progressFill.style.width = `${percentage}%`;
                progressFill.style.transition = 'width 0.5s ease-out';
                
                // Add color transitions based on progress
                if (percentage < 33) {
                    progressFill.style.background = 'linear-gradient(90deg, #ef4444, #f97316)';
                } else if (percentage < 66) {
                    progressFill.style.background = 'linear-gradient(90deg, #f97316, #eab308)';
                } else {
                    progressFill.style.background = 'linear-gradient(90deg, #eab308, #22c55e)';
                }
            }
            
            console.log(`Progress updated: ${cardNumber}/${totalCards} (${percentage}%)`);
        }

        function updateTestingStatistics() {
            // Calculate current statistics
            const answeredCards = gameState.userAnswers.filter(answer => answer !== null).length;
            const correctAnswers = gameState.userAnswers.filter(answer => answer && answer.isCorrect).length;
            const incorrectAnswers = gameState.userAnswers.filter(answer => answer && !answer.isCorrect && !answer.isSkipped).length;
            const skippedAnswers = gameState.userAnswers.filter(answer => answer && answer.isSkipped).length;
            
            const currentAccuracy = answeredCards > 0 ? Math.round((correctAnswers / answeredCards) * 100) : 0;
            
            // Update statistics display if elements exist
            const statsElement = document.getElementById('testing-stats');
            if (statsElement) {
                statsElement.innerHTML = `
                    <div class="flex justify-between text-sm text-gray-600">
                        <span>Correct: <strong class="text-green-600">${correctAnswers}</strong></span>
                        <span>Incorrect: <strong class="text-red-600">${incorrectAnswers}</strong></span>
                        <span>Skipped: <strong class="text-yellow-600">${skippedAnswers}</strong></span>
                        <span>Accuracy: <strong class="text-blue-600">${currentAccuracy}%</strong></span>
                    </div>
                `;
            }
            
            console.log(`Statistics: ${correctAnswers} correct, ${incorrectAnswers} incorrect, ${skippedAnswers} skipped, ${currentAccuracy}% accuracy`);
        }

        function showProgressMilestone(cardNumber, totalCards) {
            const percentage = Math.round((cardNumber / totalCards) * 100);
            
            // Show milestone celebrations at 25%, 50%, 75%, and 100%
            if (percentage === 25 || percentage === 50 || percentage === 75 || percentage === 100) {
                let message = '';
                let type = 'success';
                
                switch(percentage) {
                    case 25:
                        message = '🎉 Quarter way through! Keep going!';
                        break;
                    case 50:
                        message = '🔥 Halfway done! You\'re doing great!';
                        break;
                    case 75:
                        message = '⭐ Three quarters complete! Almost there!';
                        break;
                    case 100:
                        message = '🏆 All cards completed! Excellent work!';
                        break;
                }
                
                setTimeout(() => {
                    showProgressFeedback(message, type);
                }, 100);
            }
        }

        function initializeTestingProgress() {
            // Initialize progress display
            updateTestingProgress();
            updateTestingStatistics();
            
            // Set up progress bar styling
            const progressFill = document.getElementById('testing-progress-fill');
            if (progressFill) {
                progressFill.style.width = '0%';
                progressFill.style.background = 'linear-gradient(90deg, #ef4444, #f97316)';
                progressFill.style.transition = 'width 0.5s ease-out, background 0.3s ease-out';
            }
        }

        // Enhanced start testing function
        function startTesting() {
            console.log('Starting testing phase');
            
            // Initialize testing state
            gameState.phase = 'testing';
            gameState.testingIndex = 0;
            gameState.userAnswers = new Array(gameState.totalCards).fill(null);
            
            // Show testing phase
            setPhase('testing');
            
            // Initialize testing interface
            const initialized = initializeTestingPhase();
            
            if (initialized) {
                // Initialize progress tracking
                initializeTestingProgress();
                
                // Update question and progress
                updateTestingQuestion();
                updateTestingProgress();
                updateTestingStatistics();
                
                console.log('Testing phase started successfully');
                return true;
            } else {
                console.error('Failed to initialize testing phase');
                return false;
            }
        }

        // Comprehensive Answer Validation and Submission Logic

        function validateAnswer(suit, rank) {
            const errors = [];
            
            // Validate suit
            if (!suit || suit.trim() === '') {
                errors.push('Please select a suit');
            } else if (!SUITS.includes(suit)) {
                errors.push('Invalid suit selected');
            }
            
            // Validate rank
            if (!rank || rank.trim() === '') {
                errors.push('Please select a rank');
            } else if (!RANKS.includes(rank)) {
                errors.push('Invalid rank selected');
            }
            
            // Check game state
            if (gameState.phase !== 'testing') {
                errors.push('Not in testing phase');
            }
            
            if (gameState.testingIndex >= gameState.totalCards) {
                errors.push('No more cards to test');
            }
            
            if (gameState.testingIndex < 0) {
                errors.push('Invalid card index');
            }
            
            return {
                valid: errors.length === 0,
                errors: errors
            };
        }

        function processAnswer(suit, rank) {
            // Validate the answer first
            const validation = validateAnswer(suit, rank);
            
            if (!validation.valid) {
                console.error('Answer validation failed:', validation.errors);
                return {
                    success: false,
                    errors: validation.errors
                };
            }
            
            try {
                // Get the current card
                const currentCard = gameState.cards[gameState.testingIndex];
                if (!currentCard) {
                    throw new Error('Current card not found');
                }
                
                // Check if answer is correct
                const isCorrect = currentCard.equals(suit, rank);
                
                // Store the answer
                gameState.userAnswers[gameState.testingIndex] = {
                    suit: suit,
                    rank: rank,
                    isCorrect: isCorrect,
                    isSkipped: false,
                    timestamp: Date.now(),
                    cardPosition: gameState.testingIndex + 1
                };
                
                // Log the submission
                console.log(`Answer processed: ${rank}${SUIT_SYMBOLS[suit]} for position ${gameState.testingIndex + 1}, Correct: ${isCorrect}`);
                
                return {
                    success: true,
                    isCorrect: isCorrect,
                    correctCard: currentCard,
                    userAnswer: {
                        suit: suit,
                        rank: rank,
                        display: `${rank}${SUIT_SYMBOLS[suit]}`
                    }
                };
                
            } catch (error) {
                console.error('Error processing answer:', error);
                return {
                    success: false,
                    errors: ['Failed to process answer: ' + error.message]
                };
            }
        }

        function processSkip() {
            try {
                // Check game state
                if (gameState.phase !== 'testing') {
                    throw new Error('Not in testing phase');
                }
                
                if (gameState.testingIndex >= gameState.totalCards) {
                    throw new Error('No more cards to skip');
                }
                
                // Get the current card for logging
                const currentCard = gameState.cards[gameState.testingIndex];
                
                // Store the skip
                gameState.userAnswers[gameState.testingIndex] = {
                    suit: null,
                    rank: null,
                    isCorrect: false,
                    isSkipped: true,
                    timestamp: Date.now(),
                    cardPosition: gameState.testingIndex + 1
                };
                
                console.log(`Card skipped: position ${gameState.testingIndex + 1} (${currentCard ? currentCard.getDisplayString() : 'unknown'})`);
                
                return {
                    success: true,
                    skippedCard: currentCard
                };
                
            } catch (error) {
                console.error('Error processing skip:', error);
                return {
                    success: false,
                    errors: ['Failed to skip card: ' + error.message]
                };
            }
        }

        function canSubmitAnswer() {
            // Check if we can submit an answer
            if (gameState.phase !== 'testing') {
                return { canSubmit: false, reason: 'Not in testing phase' };
            }
            
            if (gameState.testingIndex >= gameState.totalCards) {
                return { canSubmit: false, reason: 'No more cards to test' };
            }
            
            // Check if answer already submitted for this card
            const existingAnswer = gameState.userAnswers[gameState.testingIndex];
            if (existingAnswer && existingAnswer !== null) {
                return { canSubmit: false, reason: 'Answer already submitted for this card' };
            }
            
            return { canSubmit: true };
        }

        function getTestingProgress() {
            return {
                currentIndex: gameState.testingIndex,
                totalCards: gameState.totalCards,
                percentage: Math.round(((gameState.testingIndex + 1) / gameState.totalCards) * 100),
                answeredCards: gameState.userAnswers.filter(answer => answer !== null).length,
                correctAnswers: gameState.userAnswers.filter(answer => answer && answer.isCorrect).length,
                incorrectAnswers: gameState.userAnswers.filter(answer => answer && !answer.isCorrect && !answer.isSkipped).length,
                skippedAnswers: gameState.userAnswers.filter(answer => answer && answer.isSkipped).length
            };
        }

        // Enhanced validation for the existing functions
        function submitAnswer(suit, rank) {
            const result = processAnswer(suit, rank);
            
            if (result.success) {
                return {
                    correctCard: result.correctCard,
                    isCorrect: result.isCorrect
                };
            } else {
                console.error('Submit answer failed:', result.errors);
                return null;
            }
        }

        function skipAnswer() {
            const result = processSkip();
            return result.success;
        }

        // Results Display and Statistics Functions

        function updateResultsInterface() {
            console.log('Updating results interface');
            
            try {
                // Update overall statistics
                updateResultsStatistics();
                
                // Populate results table
                populateResultsTable();
                
                // Generate performance analysis
                generatePerformanceAnalysis();
                
                // Add entrance animations
                animateResultsEntrance();
                
                console.log('Results interface updated successfully');
            } catch (error) {
                console.error('Error updating results interface:', error);
            }
        }

        function updateResultsStatistics() {
            // Update statistics display
            const stats = gameState.stats;
            
            // Update stat cards
            const totalCardsElement = document.getElementById('total-cards-stat');
            const correctAnswersElement = document.getElementById('correct-answers-stat');
            const incorrectAnswersElement = document.getElementById('incorrect-answers-stat');
            const skippedAnswersElement = document.getElementById('skipped-answers-stat');
            const accuracyElement = document.getElementById('accuracy-percentage');
            
            if (totalCardsElement) {
                animateNumber(totalCardsElement, 0, stats.totalCards, 1000);
            }
            
            if (correctAnswersElement) {
                setTimeout(() => {
                    animateNumber(correctAnswersElement, 0, stats.correctAnswers, 1000);
                }, 200);
            }
            
            if (incorrectAnswersElement) {
                setTimeout(() => {
                    animateNumber(incorrectAnswersElement, 0, stats.incorrectAnswers, 1000);
                }, 400);
            }
            
            if (skippedAnswersElement) {
                setTimeout(() => {
                    animateNumber(skippedAnswersElement, 0, stats.skippedAnswers, 1000);
                }, 600);
            }
            
            if (accuracyElement) {
                setTimeout(() => {
                    animateNumber(accuracyElement, 0, stats.correctPercentage, 1500, '%');
                }, 800);
            }
        }

        function populateResultsTable() {
            const tableBody = document.getElementById('results-table-body');
            if (!tableBody) {
                console.error('Results table body not found');
                return;
            }
            
            // Clear existing content
            tableBody.innerHTML = '';
            
            // Create table rows
            for (let i = 0; i < gameState.cards.length; i++) {
                const card = gameState.cards[i];
                const userAnswer = gameState.userAnswers[i];
                
                const row = document.createElement('tr');
                
                // Determine result type and styling
                let resultType = 'skipped';
                let resultText = 'Skipped';
                let resultClass = 'result-skipped';
                
                if (userAnswer) {
                    if (userAnswer.isSkipped) {
                        resultType = 'skipped';
                        resultText = 'Skipped';
                        resultClass = 'result-skipped';
                    } else if (userAnswer.isCorrect) {
                        resultType = 'correct';
                        resultText = 'Correct';
                        resultClass = 'result-correct';
                    } else {
                        resultType = 'incorrect';
                        resultText = 'Incorrect';
                        resultClass = 'result-incorrect';
                    }
                }
                
                row.className = resultClass;
                
                // Position column
                const positionCell = document.createElement('td');
                positionCell.innerHTML = `<strong>#${i + 1}</strong>`;
                row.appendChild(positionCell);
                
                // Correct card column
                const correctCardCell = document.createElement('td');
                const correctCardSpan = document.createElement('span');
                correctCardSpan.className = `card-display ${card.getSuitClass()}`;
                correctCardSpan.textContent = card.getDisplayString();
                correctCardCell.appendChild(correctCardSpan);
                row.appendChild(correctCardCell);
                
                // User answer column
                const userAnswerCell = document.createElement('td');
                if (userAnswer && !userAnswer.isSkipped) {
                    const userAnswerSpan = document.createElement('span');
                    userAnswerSpan.className = `card-display ${userAnswer.suit.toLowerCase()}`;
                    userAnswerSpan.textContent = `${userAnswer.rank}${SUIT_SYMBOLS[userAnswer.suit]}`;
                    userAnswerCell.appendChild(userAnswerSpan);
                } else {
                    userAnswerCell.innerHTML = '<span class="text-gray-500 italic">Not answered</span>';
                }
                row.appendChild(userAnswerCell);
                
                // Result column
                const resultCell = document.createElement('td');
                resultCell.style.textAlign = 'center';
                const resultBadge = document.createElement('span');
                resultBadge.className = `result-badge ${resultType}`;
                resultBadge.textContent = resultText;
                resultCell.appendChild(resultBadge);
                row.appendChild(resultCell);
                
                tableBody.appendChild(row);
            }
            
            console.log(`Results table populated with ${gameState.cards.length} rows`);
        }

        function generatePerformanceAnalysis() {
            const analysisContainer = document.getElementById('performance-analysis');
            if (!analysisContainer) {
                console.error('Performance analysis container not found');
                return;
            }
            
            // Clear existing content
            analysisContainer.innerHTML = '';
            
            const stats = gameState.stats;
            
            // Performance grade
            const gradeCard = document.createElement('div');
            gradeCard.className = 'bg-white p-6 rounded-lg shadow-lg border';
            
            let grade = 'F';
            let gradeColor = 'text-red-600';
            let gradeMessage = 'Keep practicing!';
            
            if (stats.correctPercentage >= 90) {
                grade = 'A+';
                gradeColor = 'text-green-600';
                gradeMessage = 'Outstanding memory skills!';
            } else if (stats.correctPercentage >= 80) {
                grade = 'A';
                gradeColor = 'text-green-600';
                gradeMessage = 'Excellent performance!';
            } else if (stats.correctPercentage >= 70) {
                grade = 'B';
                gradeColor = 'text-blue-600';
                gradeMessage = 'Good job!';
            } else if (stats.correctPercentage >= 60) {
                grade = 'C';
                gradeColor = 'text-yellow-600';
                gradeMessage = 'Room for improvement';
            } else if (stats.correctPercentage >= 50) {
                grade = 'D';
                gradeColor = 'text-orange-600';
                gradeMessage = 'Practice more';
            }
            
            gradeCard.innerHTML = `
                <h4 class="text-lg font-semibold mb-3 text-gray-700">Performance Grade</h4>
                <div class="text-center">
                    <div class="text-6xl font-bold ${gradeColor} mb-2">${grade}</div>
                    <div class="text-sm text-gray-600">${gradeMessage}</div>
                </div>
            `;
            
            // Detailed breakdown
            const breakdownCard = document.createElement('div');
            breakdownCard.className = 'bg-white p-6 rounded-lg shadow-lg border';
            
            const totalAnswered = stats.correctAnswers + stats.incorrectAnswers;
            const answerRate = totalAnswered > 0 ? Math.round((totalAnswered / stats.totalCards) * 100) : 0;
            
            breakdownCard.innerHTML = `
                <h4 class="text-lg font-semibold mb-3 text-gray-700">Performance Breakdown</h4>
                <div class="space-y-3">
                    <div class="flex justify-between">
                        <span class="text-gray-600">Cards Attempted:</span>
                        <span class="font-semibold">${totalAnswered}/${stats.totalCards} (${answerRate}%)</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-600">Success Rate:</span>
                        <span class="font-semibold text-green-600">${stats.correctPercentage}%</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-600">Cards Skipped:</span>
                        <span class="font-semibold text-yellow-600">${stats.skippedAnswers}</span>
                    </div>
                    ${generateRecommendations()}
                </div>
            `;
            
            analysisContainer.appendChild(gradeCard);
            analysisContainer.appendChild(breakdownCard);
        }

        function generateRecommendations() {
            const stats = gameState.stats;
            const recommendations = [];
            
            if (stats.correctPercentage < 70) {
                recommendations.push('💡 Try using memory techniques like visualization or association');
            }
            
            if (stats.skippedAnswers > stats.totalCards * 0.3) {
                recommendations.push('⏰ Take more time during the memorization phase');
            }
            
            if (stats.correctPercentage >= 80) {
                recommendations.push('🎯 Try increasing the number of decks for a greater challenge');
            }
            
            if (recommendations.length === 0) {
                recommendations.push('👍 Good job! Keep practicing to improve further');
            }
            
            return recommendations.map(rec => `
                <div class="text-sm text-blue-600 bg-blue-50 p-2 rounded border border-blue-200">
                    ${rec}
                </div>
            `).join('');
        }

        function animateNumber(element, start, end, duration, suffix = '') {
            const startTime = performance.now();
            
            function updateNumber(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing function for smooth animation
                const easeOutQuart = 1 - Math.pow(1 - progress, 4);
                const current = Math.round(start + (end - start) * easeOutQuart);
                
                element.textContent = current + suffix;
                
                if (progress < 1) {
                    requestAnimationFrame(updateNumber);
                }
            }
            
            requestAnimationFrame(updateNumber);
        }

        function animateResultsEntrance() {
            // Animate stat cards
            const statCards = document.querySelectorAll('.stat-card');
            statCards.forEach((card, index) => {
                setTimeout(() => {
                    slideIn(card, 'up', 600);
                }, index * 100);
            });
            
            // Animate accuracy display
            setTimeout(() => {
                const accuracyDisplay = document.querySelector('#accuracy-percentage').parentElement;
                if (accuracyDisplay) {
                    bounceIn(accuracyDisplay, 800);
                }
            }, 800);
            
            // Animate table
            setTimeout(() => {
                const table = document.getElementById('results-table');
                if (table) {
                    fadeIn(table, 600);
                }
            }, 1200);
            
            // Animate performance analysis
            setTimeout(() => {
                const analysis = document.getElementById('performance-analysis');
                if (analysis) {
                    slideIn(analysis, 'left', 600);
                }
            }, 1600);
        }

        // Action button handlers

        function startNewGame() {
            const confirmed = confirm('Start a new game? This will reset all current progress.');
            
            if (confirmed) {
                // Reset game state
                gameState.reset();
                
                // Show setup phase
                setPhase('setup');
                
                console.log('New game started');
            }
        }

        function retryWithSameCards() {
            const confirmed = confirm('Retry with the same cards? You will memorize and test the same deck again.');
            
            if (confirmed) {
                // Keep the same cards but reset testing state
                gameState.phase = 'memorization';
                gameState.currentCardIndex = 0;
                gameState.testingIndex = 0;
                gameState.userAnswers = [];
                
                // Reset statistics
                gameState.stats = {
                    totalCards: gameState.totalCards,
                    correctAnswers: 0,
                    incorrectAnswers: 0,
                    skippedAnswers: 0,
                    correctPercentage: 0
                };
                
                // Show memorization phase
                setPhase('memorization');
                
                // Initialize memorization interface
                initializeMemorizationPhase();
                
                console.log('Retrying with same cards');
            }
        }

        function exportResults() {
            try {
                const results = {
                    timestamp: new Date().toISOString(),
                    gameConfiguration: {
                        numDecks: gameState.numDecks,
                        totalCards: gameState.totalCards
                    },
                    statistics: gameState.stats,
                    detailedResults: gameState.cards.map((card, index) => {
                        const userAnswer = gameState.userAnswers[index];
                        return {
                            position: index + 1,
                            correctCard: card.getDisplayString(),
                            userAnswer: userAnswer && !userAnswer.isSkipped ? 
                                `${userAnswer.rank}${SUIT_SYMBOLS[userAnswer.suit]}` : 'Skipped',
                            isCorrect: userAnswer ? userAnswer.isCorrect : false,
                            isSkipped: userAnswer ? userAnswer.isSkipped : true
                        };
                    })
                };
                
                // Create downloadable file
                const dataStr = JSON.stringify(results, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `memory-palace-results-${new Date().toISOString().slice(0, 19)}.json`;
                link.click();
                
                console.log('Results exported successfully');
                
                // Show feedback
                setTimeout(() => {
                    alert('Results exported successfully!');
                }, 100);
                
            } catch (error) {
                console.error('Error exporting results:', error);
                alert('Error exporting results. Please try again.');
            }
        }

        // Application Initialization
        
        // Initialize the application when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Memory Palace Cards Application loaded');
            
            // Show initial setup phase
            setPhase('setup');
            
            // Initialize any required event listeners or setup
            console.log('Application initialized successfully');
        });

        // Memory Palace Cards Application - Complete Implementation
        // This application provides a complete memory training system for playing cards
        // Features include:
        // - Multi-deck support (1-10 decks)
        // - Interactive memorization phase with smooth animations
        // - Comprehensive testing phase with immediate feedback
        // - Detailed results analysis with performance grading
        // - Export functionality for results tracking
        // - Responsive design for all devices
        // - Professional UI with modern styling and animations
    </script>
</body>
</html> 